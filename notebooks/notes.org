#+OPTIONS: toc:nil

# Read-only tangled files
#+PROPERTY: header-args :tangle-mode (identity #o444)
# Set Jupyter kernel/session options for emacs-jupyter
#+PROPERTY: header-args:jupyter-julia :session MultilinearMaps :kernel julia-official-zink :eval no-export :async yes :exports both

:TEX_MATHJAX_SETUP:
#+LATEX_COMPILER: lualatex

# #+LATEX_HEADER: \usepackage[margin=48bp,paperwidth=7in,paperheight=10in]{geometry}
#+LATEX_HEADER: \AtBeginDocument{\renewcommand*{\vec}{\symbf}}
#+LATEX_HEADER: \AtBeginDocument{\newcommand*{\uvec}[1]{\hat{\vec #1}}}
#+LATEX_HEADER: \newcommand*{\norm}[1]{|#1|}
#+LATEX_HEADER: \newcommand*{\ten}{\symbfsf}
#+LATEX_HEADER: \newcommand*{\pd}{\partial}
#+LATEX_HEADER: \newcommand*{\grad}{\vec\nabla}
#+LATEX_HEADER: \newcommand*\dd{\mathop{}\!\mathrm{d}}
#+LATEX_HEADER: \newcommand*\Reals{\symbb R}
#+LATEX_HEADER: \DeclareMathOperator{\supp}{supp}

#+LATEX_HEADER: \setmainfont{STIX Two Text}
#+LATEX_HEADER: \setmathfont{STIX Two Math}
#+LATEX_HEADER: \setmonofont{JuliaMono}

#+LATEX_HEADER: \setlength{\parindent}{0pt}
#+LATEX_HEADER: \setlength{\parskip}{\medskipamount}

# Macros for MathJAX
#+begin_export html
\(
\newcommand{\pd}{\partial}
\renewcommand{\vec}{\boldsymbol}
\newcommand{\uvec}[1]{\hat{\vec #1}}
\renewcommand{\ten}[1]{\boldsymbol{\mathsf{#1}}}
\newcommand\dd{\mathop{}\!\mathrm{d}}
\newcommand{\grad}{\vec\nabla}
\newcommand{\symbb}{\mathbb}
\newcommand{\Reals}{\symbb R}
\newcommand\NRe{\mathinner{Re}}
\newcommand{\norm}[1]{|#1|}
\DeclareMathOperator{\supp}{supp}
\)
#+end_export
:END:

:JULIA_SETUP:
#+begin_src jupyter-julia :results silent :exports none
using LinearAlgebra
using Static
using ArrayInterface: ArrayInterface as Arr
using ArrayInterfaceStaticArrays
using StaticArrays
using StaticArrays: sacollect
using MultilinearMaps

using Test
using BenchmarkTools

if !@isdefined(BenchmarkTools)
    macro btime(args...)
        :(println("<benchmark skipped>"))
    end
    macro benchmark(args...)
        :(println("<benchmark skipped>"))
    end
end

showit(x) = (show(stdout, "text/plain", x); println())
showit_ret(x) = (show(stdout, "text/plain", x); println(); x)
#+end_src
:END:


#+TITLE: ~MultilinearMaps~


* Introduction

Multilinear maps (see also [[wikipedia:Multilinear_map][Wikipedia]] and [[https://www.isical.ac.in/~arnabc/q/tensor.html][this page]]) are functions of \(K\) vectors (potentially belonging to different vector spaces) and map them to vectors in an output vector space \(W\).
Thus, a multilinear map is a function
\begin{equation*}
f : V_1 ⋯ V_K → W
\end{equation*}
If the codomain of \(f\) is a field of scalars, then we call \(f\) a [[wikipedia:Multilinear_form][multilinear form]].
If \(M\) of the \(V_1, ⋯, V_K\) are a vector space \(V\) and the remaining \(N\) are the dual space of \(V\), \(V^*\), then \(f\) is called a \((M,N)\)-tensor.
A familiar example of a multilinear map (a multilinear form in this case) is the standard inner product (dot product) of vectors, which is a bilinear form (also called a 2-linear form or a 2nd-order multilinear form).
It takes two vectors and produces a scalar.

The most general form of a \(K\)-linear map is
\begin{equation*}
  f(v_1, ⋯, v_K) = \sum_{i_1}^{D_1} ⋯ \sum_{i_K}^{D_K} \vec A_{i_1 ⋯ i_K} v_{1 i_1} ⋯ v_{K i_K}
\end{equation*}
where \(D_j\) gives the dimension of the vector space to which \(\vec v_j\) belongs.
That is, \(f\) can be represented by an \(K\)-dimensional array of components.
The components \(\vec A_{i_1, ⋯, i_k}\) are given by setting each of the vector arguments to one of the standard unit vectors \(\uvec e_i\) for \(i ∈ 1 ⋯ D_j\); \( \vec A_{i_i ⋯ i_k} = f(\uvec e_{i_1}, ⋯, \uvec e_{i_K})\)
For the inner product, \(\uvec e_i ⋅ \uvec e_j \) the components are that of the Kronecker delta \(δ_{ij}\).
However, representing multilinear maps as functions on vectors (rather than arrays) in computational code is useful, especially if \(f\) has special structure.
(For instance, computing an inner product by naively multiplying by the identity matrix by \(v_1\) on the left and \(v_2\) on the right is not very efficient.)

Here is an example of a 4-linear form, which takes four vectors and produces a scalar
#+begin_src jupyter-julia :results silent :tangle test/examples.jl
@inline _skew(v1, v2, v3, v4) = ((v1⋅v3)*(v2⋅v4) - (v1⋅v4)*(v2⋅v3))
@inline _skew(vs::NTuple{4}) = _skew(vs...)
#+end_src
and has components \(δ_{ik} δ_{jl} - δ_{il} δ_{jk}\).
It is one of the three isotropic Cartesian tensors.
We can compute the components as follows for the three-dimensional case.
#+begin_src jupyter-julia
let e1 = SVector(1.,0,0),
    e2 = SVector(0,1.,0),
    e3 = SVector(0,0,1.)   # unit vectors in ℝ³

    @show A_1231 = _skew(e1, e2, e3, e1)
    @show A_1212 = _skew(e1, e2, e1, e2)
end;
#+end_src

#+RESULTS:
: A_1231 = _skew(e1, e2, e3, e1) = 0.0
: A_1212 = _skew(e1, e2, e1, e2) = 1.0

Now, this is not as efficient as it could be we are using ~LinearAlgebra.dot~ (~⋅~) on "literal" unit vectors, so there is going to be some unnecesary ~0*0~ or ~1*0~ operations.

** Functions on indices

The following functions are similar to ~dot~ and ~_skew~, but are directly functions of indices rather than vectors.  They are essentially equivalent if one restricts attention to arguments ~v1, ⋯, vN~ being one of the standard unit vectors \(\uvec e_1 ⋯ \uvec e_N\), but the "index" versions are less flexible for the same reason---they cannot take in any set of vectors.
On the other hand, the "index" versions directly and efficiently give the components of a multilinear map.
#+begin_src jupyter-julia :results silent :tangle test/examples.jl
# The Kronecker delta, δ_{ij}, as a function of indices
inner_ixfn(i, j) = (i==j)
@inline inner_ixfn(args::Dims{2}) = inner_ixfn(args...)
@inline inner_ixfn(I::CartesianIndex{2}) = inner_ixfn(Tuple(I)...)

# A 4th order isotropic tensor, δ_{ik} δ_{jl} - δ_{il} δ_{jk}
skew_ixfn(i, j, k, l) = (i==k) * (j==l) - (i==l) * (j==k)
@inline skew_ixfn(args::Dims{4}) = skew_ixfn(args...)
@inline skew_ixfn(I::CartesianIndex{4}) = skew_ixfn(Tuple(I)...)
#+end_src

We can loop over functions like these to fill up an array of components.
(In [[file:src/util.jl]], we define ~fillfn!~, which has this job.)


#+begin_src jupyter-julia
using Base.Cartesian

@generated function fillfn_nloops!(arr::AbstractArray{<:Any,N}, f::F) where {N,F}
    quote
        @nloops $N i arr begin
            @inbounds (@nref $N arr i) = (@ncall $N f i)
        end
        arr
    end
end

function fillfn_cartesianindices!(arr::AbstractArray, f::F) where F
    @inbounds for I ∈ CartesianIndices(arr)
        arr[I] = f(Tuple(I)...)
    end
    return arr
end

let A = MArray{NTuple{4,3},Float64}(undef)
    # @btime materialize!(skew, $A)
    println("  Using `CartesianIndices`")
    out1 = @btime fillfn_cartesianindices!($A, $skew_ixfn)
    println("  Using `Base.Cartesian`")
    out2 = @btime fillfn_nloops!($A, $skew_ixfn)
    println("`SArray` via `sacollect`")
    out3 = @btime(
        sacollect(SArray{NTuple{4,3}}, $skew_ixfn(I) for I ∈ Is),
        setup=(Is = CartesianIndices(ntuple(_ -> SOneTo(3), Val(4))))
    )
    @assert out1 == out2 == out3
end
#+end_src

#+RESULTS:
:   Using `CartesianIndices`
:   96.924 ns (0 allocations: 0 bytes)
:   Using `Base.Cartesian`
:   13.016 ns (0 allocations: 0 bytes)
: `SArray` via `sacollect`
:   13.297 ns (0 allocations: 0 bytes)

*Developer Note.*
Use of ~sacollect~ is most efficient because it effectively unrolls all the loops.
However, using approaches with looping might be beneficial in cases where loop unrolling would create too much work for the compiler.

The key to maintaining the flexibility of something like ~_skew~ while retaining the efficiency of ~skew_ixfn~ for computing components is simply to define a special unit vector type that knows how to interact with other unit vectors as well as "regular" vectors.
We will try to sacrifice as little performance over the "baseline" functions on indices as possible in our implementation below.


* Unit vectors and indices

There is not much distinction between functions on indices and multilinear maps on the standard unit vectors because the index \(i\) directly maps over to the unit vector \(e_i\) pointing in the \(i\)th direction.
We therefore define ~StandardUnitVector(i, n)~ (see [[file:src/StandardBasis.jl][StdandardBasis.jl]]) to represent a standard unit vector that points in the ~i~-th direction of a ~n~-dimensional vector space.
We also alias ~StdUnitVec = StandardUnitVector~.

Some notes about the implementation:
- the dot product (~LinearAlgebra.dot~) of two ~StdUnitVec~​s amounts to checking if they point in the same direction; ~e1 ⋅ e2 := e1.direction == e2.direction~
  - the dot product of a ~StdUnitVec~ with a "regular" vector just performs indexing; ~e ⋅ v := v[e.direction]~
- the dot product of any other kinds of "regular" vectors just falls back to the usual algorithm given by ~LinearAlgebra.dot~

Now, if we evaluate ~dot~ where the operands are pairs of ~StdUnitVector~​s, we really just have a function that tests whether the ~direction~ of each vector is the same.
For example, the dot product between two unit vectors, ~[1, 0, 0]~ and ~[0, 0, 1]~, is reduced to testing whether ~1==3~, which evaluates to ~false == 0~.

Below, we construct a \(3×3\) identity matrix using ~StdUnitVec~​s.
#+begin_src jupyter-julia :results scalar
let b = StandardBasis(3)
    @btime [e1 ⋅ e2 for e1 ∈ $b, e2 ∈ $b]
end
#+end_src

#+RESULTS:
:RESULTS:
:   32.705 ns (1 allocation: 64 bytes)
: 3×3 Matrix{Bool}:
:  1  0  0
:  0  1  0
:  0  0  1
:END:

Note that the matrix elements are of type ~Bool~.
This is a direct result of the boolean tests performed for each element of the matrix.
Indeed, the code above is equivalent to
#+begin_src julia :exports code :eval no
[i == j for j ∈ 1:3, i ∈ 1:3]
#+end_src


** Tests

#+begin_src jupyter-julia
using Test

@testset "Unit Vectors" begin
    e1 = StandardBasis(1)
    e2 = StandardBasis(2)
    e3 = StandardBasis(3)

    @testset "Construction" begin
        @test size(e2[1]) == (2,)
        @test length(e2[1]) == only(size(e2[1]))
        @test_throws DomainError StandardBasis(1)[0]
        @test_throws DomainError StandardBasis(2)[3]
        @test only(StandardBasis(1)[1])
    end
    @testset "Equality" begin
        @test e2[1] == e2[1]
        @test e2[1] !== e2[2]
        @test e2[1] !== e3[1]
        @test e2[1] == Bool[true, false]
        @test e2[1] !== Bool[true, false, false]
    end
    @testset "Dot product" begin
        @test @inferred e1[1] ⋅ e1[1]
        @test e2[1] ⋅ e2[1]
        @test !(e2[1] ⋅ e2[2])
        @test !(e2[2] ⋅ e2[1])
        @test e2[1] ⋅ [1,2] == [1,2] ⋅ e2[1] == 1
        @test e2[2] ⋅ [1,2] == [1,2] ⋅ e2[2] == 2
        @test e2[1] ⋅ SVector(1,2) == SVector(1,2) ⋅ e2[1] == 1
        @test e2[2] ⋅ [1,2] == [1,2] ⋅ e2[2] == 2
        @test_throws DimensionMismatch e2[1] ⋅ e1[1]
        @test_throws DimensionMismatch SVector(1,2) ⋅ e1[1]
        @test_throws DimensionMismatch [1,2] ⋅ e1[1]
    end
    # Other
    @test @inferred(e2[2] + [1,0]) == ones(2)
    @test SVector{2}(e2[1] + e2[2]) === ones(SVector{2,eltype(true+true)})
    @test_broken SVector(e2[1] + e2[2]) === ones(SVector{2,eltype(true+true)})
end;
#+end_src

#+RESULTS:
: [0m[1mTest Summary: | [22m[32m[1mPass  [22m[39m[33m[1mBroken  [22m[39m[36m[1mTotal  [22m[39m[0m[1mTime[22m
: Unit Vectors  | [32m  23  [39m[33m     1  [39m[36m   24  [39m[0m1.7s

** Performance

When creating a unit vector, one generally wants to validate that its direction is appropriate for the vector space, i.e., ~1 ≤ d ≤ D~.
Indeed, constructing a two-dimensional unit vector pointing into the third dimension is invalid and will helpfully raise an exception.
#+begin_src jupyter-julia :eval no
StandardBasis(2)[3]  # raises error
#+end_src

#+begin_src jupyter-julia :results scalar
import MultilinearMaps: StandardUnitVector

@inline inds2uvecs(inds::Vararg{Int}) = map(i -> StandardUnitVector(i, 3), inds)

println("Function of indices")
out_ixfn = @btime fillfn_nloops!(A, skew_ixfn) setup=(A = MArray{NTuple{4,3},Int64}(undef))
println("Funcion of unit vectors")
out_uvs = @btime(fillfn_nloops!(A, _skew ∘ inds2uvecs),
                  setup=(A = MArray{NTuple{4,3},Int64}(undef)))
@assert out_ixfn == out_uvs
#+end_src

#+RESULTS:
: Function of indices
:   22.087 ns (0 allocations: 0 bytes)
: Funcion of unit vectors
:   17.653 ns (0 allocations: 0 bytes)

Interestingly, completely explicit loops are little faster, but why?

#+begin_src jupyter-julia
@btime(
    # begin for l ∈ axes(A,4), k ∈ axes(A,3), j ∈ axes(A,2), i ∈ axes(A,1)
    begin for l ∈ axes(A,4), k ∈ axes(A,3), j ∈ axes(A,2), i ∈ axes(A,1)
        @inbounds A[i,j,k,l] = _skew(e[i], e[j], e[k], e[l])
    end
    A
    end,
    setup=(A = MArray{NTuple{4,3}, Int64}(undef);
           e = StandardBasis(3))
);
#+end_src

#+begin_src jupyter-julia
sacollect(SArray{Tuple{4,3}, Int64}, _)
#+end_src

* Multilinear maps

In [[file:src/MultilinearMaps.jl][MultilinearMaps.jl]], we define a callable type ~MultilinearMap~ whose instances represent multilinear forms.
A ~MultilinearMap~ is constructed by passing an "implementation" function like ~LinearAlgebra.dot~ or ~_skew~.
We'll restrict our attention to the case where the vectors operated on by a given ~MultilinearMap~ are of known spatial dimension (~length~), usually being between 1--4 and most commonly 2 or 3.
Thus, we represent such vectors using types from ~StaticArrays~ for efficiency.

Let's define a few ~MultilinearMaps~ (in three dimensions) to work on below.
#+begin_src jupyter-julia
const ê = StandardUnitVector  # For convenience
_just_true() = true
const onlytrue = MultilinearMap(() -> true, ())
const inner = MultilinearMap(dot, static((3,3)))
const skew = MultilinearMap(_skew, static((3,3,3,3)))
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: invalid redefinition of constant inner
:
: Stacktrace:
:  [1] top-level scope
:    @ In[13]:4
:  [2] eval
:    @ ./boot.jl:368 [inlined]
:  [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String)
:    @ Base ./loading.jl:1428
:END:

Check that things work correctly.

#+begin_src jupyter-julia
@code_warntype MultilinearMaps._eltype(skew)
#+end_src

#+begin_src jupyter-julia
using Test

# @testset "ApplyMode" begin
#     @test MM.ApplyMode() === MM.FullApply()
#     @test MM.ApplyMode([1,2], [3,4,5], [5,6]) === MM.FullApply()
#     @test MM.ApplyMode([1,2,3,4], :, [5,6]) === MM.PartialApply()
# end;
@testset "MultilinearMap Evaluation" begin
    e = StandardBasis(3)
    u = e[1]
    v = e[2]
    onlytrue = @inferred MultilinearMap(() -> true, ())
    inner = @inferred MultilinearMap(dot, (2,2))
    skew = @inferred MultilinearMap(_skew, (2,2,2,2))
    @test onlytrue() == true
    @test_throws ArgumentError onlytrue(u)
    @test inner(u,u) == 1
    @test inner(u,v) == 0
    @test inner(v,u) == 0
    @test_throws ArgumentError inner(u)
    @test skew(u,u,v,v) == 0
    @test skew(u,v,u,v) == 1
    @test skew(u,v,v,u) == -1
end;
#+end_src

#+RESULTS:
: [0m[1mTest Summary:             | [22m[32m[1mPass  [22m[39m[36m[1mTotal  [22m[39m[0m[1mTime[22m
: MultilinearMap Evaluation | [32m   9  [39m[36m    9  [39m[0m0.1s
Check that things work efficiently (no allocations, e.g.).

#+begin_src jupyter-julia :results scalar
using BenchmarkTools
using Test

let u = SVector(1, 0, 0), v = SVector{3}(0, 1, 0)
    inner = MultilinearMap(dot, (3,3))
    skew = MultilinearMap(_skew, (3,3,3,3))
    println("Contraction, map with argument dimensions $(size(inner))")
    @assert 1 == @btime($inner($(u,u)...))
    println("Contraction, map with argument dimensions $(size(skew))")
    @assert 1 == @btime($skew($(u,v,u,v)...))
end
#+end_src

#+RESULTS:
: Contraction, map with argument dimensions (3, 3)
:   2.304 ns (0 allocations: 0 bytes)
: Contraction, map with argument dimensions (3, 3, 3, 3)
:   4.749 ns (0 allocations: 0 bytes)

** Partial application (contraction)

We can think of a ~MultilinearMap~ applied to only ~N~ of its ~K~ arguments as a similar multilinear map of order ~K-N~.
We call such a multilinear form "contracted", which is implemented by ~ContractedMultilinearForm~.
We also use the ~Colon~ (~:~) to indicate a "free index" of the tensor / form.
When a ~MultilinearForm~ is ~collect~​ed into an array, the ~:~ indicates slots/indices which should be looped over for all the unit vectors to generate numerical components.

#+begin_src jupyter-julia :results scalar
let basis = StandardBasis(3)
    e1 = basis[1]
    v = SVector(1,2,3)
    x = inner(v, :)
    [x(e) for e ∈ basis]
end
#+end_src

#+RESULTS:
: 3-element Vector{Int64}:
:  1
:  2
:  3

Some tests:

#+begin_src jupyter-julia
@testset "PartialMap" begin
    let
        e = StandardUnitVector(1, 2)
        inner = @inferred MultilinearMap(dot, (2,2))
        @test_throws ArgumentError inner(:,:,:)
        @test_throws ArgumentError inner(:)
        @test inner(:,:) === inner
        @inferred inner(e,:)
        @test_broken inner(:,e) == inner(e,:)
    end
    let e = StandardBasis(3)
        (u,v,w,x) = ntuple(_ -> rand(SVector{3,Float64}), Val(4))
        inner = @inferred MultilinearMap(dot, (3,3))
        skew = @inferred MultilinearMap(_skew, (3,3,3,3))
        @inferred skew(u,v,w,:)
        @inferred skew(u,v,w,:)(x)
        @test_broken inner(u,v) == inner(u,:)(v) == inner(:,u)(v) == inner(:,:)(u,v)
        @test_broken skew(u,v,w,x) ≈ skew(u,v,w,:)(x) ≈ skew(u,v,:,:)(w,x) ≈
            skew(u,:,:,:)(v,w,x) ≈ skew(:,v,w,x)(u)
        # @test eltype(inner(e[1], :)) == eltype(e[1])
        # @test eltype(inner(u, :)) == eltype(u)
        # @test eltype(skew(e[1], e[2], :, e[3])) == Int
    end
end;
#+end_src

#+RESULTS:
: [0m[1mTest Summary: | [22m[32m[1mPass  [22m[39m[33m[1mBroken  [22m[39m[36m[1mTotal  [22m[39m[0m[1mTime[22m
: PartialMap    | [32m   3  [39m[33m     3  [39m[36m    6  [39m[0m1.0s
We might want more functionality in the future, like the ability to permute the argument order of the vector arguments.
We leave that to later work.


* Interfaces for iteration, indexing, etc.

We can now produce an identity matrix as follows by using ~inner~, defined above, and ~StdUnitVector~.
#+begin_src jupyter-julia
@btime [inner(e1, e2) for e1 ∈ sb, e2 ∈ sb] setup=begin
    sb = StandardBasis(3)
end
#+end_src

#+RESULTS:
:RESULTS:
:   33.542 ns (1 allocation: 64 bytes)
: 3×3 Matrix{Bool}:
:  1  0  0
:  0  1  0
:  0  0  1
:END:

However, much convenience is provided by implementing the [[https://docs.julialang.org/en/v1/manual/interfaces/][iteration and indexing interfaces]] for ~MultilinearForm~​s.
This will allow us to "collect" a ~MultilinearForm~ into an array container like ~Array~ or ~SArray~ using ~collect~ or ~StaticArrays.sacollect~, respectively.
(Note that we commit some type piracy in doing so.  It would be nice if ~sacollect~ had a generic method that could handle iterators that possessed a ~Size~ trait without having to specify the size in the type ~SA~.  We have hacked that together above, but maybe something like this should be considered for inclusion in ~StaticArrays~ itself.)
Indexing is done by simply converting each index to a corresponding ~StdUnitVector~ like ~mf[i,j,...] = mf(StdUnitVector{3}(i), StdUnitVector{3}(j), ...)~, to provide a convenience shorthand.
The methods necessary to make this work are implemented in [[file:src/MultilinearForms.jl][MultilinearForms.jl]].
There, we also implement methods for ~StaticArrays.similar_type~ and ~Base.similar~ to provide appropriate types to contain components of ~MultilinearForms~.

Note that when ~@inbounds~ is used, unit vectors are unsafely constructed, without checking if their direction is valid for their dimension.

** Indexing

#+begin_src jupyter-julia :results scalar
# MM._getindex(MM.UNSAFE, inner, 1, 1)
@btime inner(StandardUnitVector(1,3), StandardUnitVector(3,3))
@btime getindex(inner, 1, 3)
@btime inner[1,3]
#+end_src

#+RESULTS:
:RESULTS:
:   1.202 ns (0 allocations: 0 bytes)
:   1.202 ns (0 allocations: 0 bytes)
:   1.202 ns (0 allocations: 0 bytes)
: false
:END:


** Iteration and Collection

The identity matrix (~inner~) can now be collected into an array with a single line of code.
#+begin_src jupyter-julia :results scalar
# @btime SArray{Tuple{3,3}, Float64}(inner)
# @btime SMatrix{3,3}(inner)
let
    inner = MultilinearMap(dot, (3,3))
    skew = MultilinearMap(_skew, (3,3,3,3))
    @btime sacollect(SMatrix{3,3}, $inner)
    # @btime sacollect(SArray{Tuple{3,3,3,3}}, $skew)
end
#+end_src

#+RESULTS:
:RESULTS:
:   7.662 ns (0 allocations: 0 bytes)
: 3×3 SMatrix{3, 3, Bool, 9} with indices SOneTo(3)×SOneTo(3):
:  1  0  0
:  0  1  0
:  0  0  1
:END:

Since the size of each dimension is usually small and a fixed constant, we integrate with ~StaticArrays~.
#+begin_src jupyter-julia
@testset "StaticArrays traits" begin
    @test StaticArrays.Length(inner) == StaticArrays.Length(3^2)
    @test StaticArrays.Length(skew) == StaticArrays.Length(3^4)
    @test StaticArrays.Size(inner) == StaticArrays.Size(3,3)
    @test StaticArrays.Size(skew) == StaticArrays.Size(3,3,3,3)
end;
#+end_src

#+RESULTS:
: [0m[1mTest Summary:       | [22m[32m[1mPass  [22m[39m[36m[1mTotal  [22m[39m[0m[1mTime[22m
: StaticArrays traits | [32m   4  [39m[36m    4  [39m[0m0.0s

We can collect after contraction / "slicing", too.
Let's get a slice or two of the ~skew~ tensor 🍕.
#+begin_src jupyter-julia
@testset "More contractions" begin
    skew_components = SArray(skew)  # Materialize the whole tensor
    # Now, slice the component array and compare it to tensor contraction
    # with the unit vectors
    @test SArray(skew(ê{3}(1), :, ê{3}(2), :)) == skew_components[1,:,2,:]
    @test SArray(skew(:, :, ê{3}(3), ê{3}(2))) == skew_components[:,:,3,2]
end;
#+end_src

#+RESULTS:
: [0m[1mTest Summary:     | [22m[32m[1mPass  [22m[39m[36m[1mTotal  [22m[39m[0m[1mTime[22m
: More contractions | [32m   2  [39m[36m    2  [39m[0m0.9s

Note that components of the tensor the user has not asked for are never computed.

*** Materialization

Create an array of type ~T~ filled with the components of ~f~.

#+begin_src jupyter-julia
@btime materialize!(A, skew) setup=(A = MArray{NTuple{4,3},Int64}(undef));
#+end_src

#+RESULTS:
:   10.416 ns (0 allocations: 0 bytes)

** Validity & Performance Checks

#+begin_src jupyter-julia :results scalar
let
    solo = MultilinearMap(() -> true, ())
    inner = MultilinearMap(dot, (3,3))
    skew = MultilinearMap(_skew, (3,3,3,3))
    @btime materialize!(Scalar, $solo)
    @btime SArray($inner)
    @btime SArray($skew#=(:,:,:,:)=#)
end;
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
#+begin_example
UndefVarError: materialize not defined

Stacktrace:
  [1] var"##core#402"(solo#389::MultilinearMap{Tuple{}, var"#14#15"})
    @ Main ~/.julia/packages/BenchmarkTools/0owsb/src/execution.jl:489
  [2] var"##sample#403"(::Tuple{MultilinearMap{Tuple{}, var"#14#15"}}, __params::BenchmarkTools.Parameters)
    @ Main ~/.julia/packages/BenchmarkTools/0owsb/src/execution.jl:495
  [3] _run(b::BenchmarkTools.Benchmark, p::BenchmarkTools.Parameters; verbose::Bool, pad::String, kwargs::Base.Pairs{Symbol, Integer, NTuple{4, Symbol}, NamedTuple{(:samples, :evals, :gctrial, :gcsample), Tuple{Int64, Int64, Bool, Bool}}})
    @ BenchmarkTools ~/.julia/packages/BenchmarkTools/0owsb/src/execution.jl:99
  [4] #invokelatest#2
    @ ./essentials.jl:731 [inlined]
  [5] #run_result#45
    @ ~/.julia/packages/BenchmarkTools/0owsb/src/execution.jl:34 [inlined]
  [6] run(b::BenchmarkTools.Benchmark, p::BenchmarkTools.Parameters; progressid::Nothing, nleaves::Float64, ndone::Float64, kwargs::Base.Pairs{Symbol, Integer, NTuple{5, Symbol}, NamedTuple{(:verbose, :samples, :evals, :gctrial, :gcsample), Tuple{Bool, Int64, Int64, Bool, Bool}}})
    @ BenchmarkTools ~/.julia/packages/BenchmarkTools/0owsb/src/execution.jl:117
  [7] #warmup#54
    @ ~/.julia/packages/BenchmarkTools/0owsb/src/execution.jl:169 [inlined]
  [8] warmup(item::BenchmarkTools.Benchmark)
    @ BenchmarkTools ~/.julia/packages/BenchmarkTools/0owsb/src/execution.jl:168
  [9] macro expansion
    @ ~/.julia/packages/BenchmarkTools/0owsb/src/execution.jl:575 [inlined]
 [10] top-level scope
    @ In[10]:5
 [11] eval
    @ ./boot.jl:368 [inlined]
 [12] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String)
    @ Base ./loading.jl:1428
#+end_example
:END:


#+begin_src jupyter-julia
let u = SVector{3}(1:3), v = SVector{3}(3:-1:1)
    @btime SArray(MultilinearForm{4,3}(_skew))
    out1 = @btime SArray(skew)[:,:,3,2]
    out2 = @btime SArray(skew(:,:, ê{3}(3), ê{3}(2)))
    @test out1 == out2
end
#+end_src

#+RESULTS:
:RESULTS:
:   12.724 ns (0 allocations: 0 bytes)
:   1.956 ns (0 allocations: 0 bytes)
:   2.235 ns (0 allocations: 0 bytes)
: [32m[1mTest Passed[22m[39m
:END:


* Linear Combinations of Multilinear Maps

Multilinear maps form a vector space.
That is, we can take linear combinations of multilinear maps and generally produce another multilinear map.

** Tests

#+begin_src jupyter-julia :results scalar
@testset "Vector Space" begin
    @testset "Equality" begin
        e = StdBasis{3}(Real)
        @test inner == inner
        @test inner != skew && skew != inner
        @test skew(e[1], :, e[2], :) != inner && inner != skew(e[1], :, e[2], :)
    end
    @testset "Scalar Multiples" begin
        @test MM.ScalarMultiple(inner, 0.5) == 0.5 * inner == inner / 2
        @test inner !== inner / 2
        @test MM.ScalarMultiple(inner, 1//2) == inner // 2 == 1//2 * inner
    end
    @testset "Sums" begin
        # Associativity
        @test (inner + inner) + inner == inner + (inner + inner) == inner + inner + inner
        # Can't add maps of unequal sizes (should probably give a more helpful exception)
        @test_throws DimensionMismatch inner + skew
    end;
    @testset "Linear Combinations" begin
        @test all(==(0), skew - skew)
        @test inner + inner == 2 * inner
        @test inner + inner + inner == 2*inner + inner == inner + 2*inner == 3*inner
        @test 2*(skew + skew) / 2 == 2*skew
    end
end;
#+end_src

#+RESULTS:
: [0m[1mTest Summary: | [22m[32m[1mPass  [22m[39m[36m[1mTotal  [22m[39m[0m[1mTime[22m
: Vector Space  | [32m  12  [39m[36m   12  [39m[0m0.9s


* Spherical harmonics

The functions below give the spherical harmonics (the traceless symmetric tensors) on \(\mathbb S^2\).
(/Note, these are great for unit tests!/ Can also check that the results are symmetric and traceless to ensure there is no regression in computing correct results.)

#+begin_src jupyter-julia :results silent :tangle test/harmonics.jl
# Functions that represent (tensor) spherical harmonics
sphharm30(_) = MultilinearForm{0,3}(() -> true)
sphharm31(n̂) = MultilinearForm{1,3}((v) -> n̂⋅v)
sphharm32(n̂) = MultilinearForm{2,3}((v1, v2) -> (n̂⋅v1)*(n̂⋅v2) - (v1⋅v2)/3 )
sphharm33(n̂) = MultilinearForm{3,3}((v1, v2, v3) ->
    (n̂⋅v1)*(n̂⋅v2)*(n̂⋅v3) - ((v1⋅v2)*(n̂⋅v3) + (v3⋅v1)*(n̂⋅v2) + (v2⋅v3)*(n̂⋅v1))/5)
#+end_src

These should be traceless and symmetric when collected into an matrix/array.
#+begin_src jupyter-julia
using Test

"""Test (recursively) if an array is traceless in every pair of indices"""
istraceless(A::AbstractArray{<:Any, 0}, _::Int) = true
istraceless(A::AbstractArray{<:Any, 1}, _::Int) = true
istraceless(A::AbstractArray{<:Any, 2}, _::Int) =
    ≈(tr(A), 0, atol=√(eps(eltype(A))))
istraceless(A::AbstractArray, dim::Int) =
    all(istraceless(B) for B in eachslice(A, dims=dim))
    # For dim = 1, does
    # all(≈(tr(out[i,:,:]), 0, atol=eps(eltype(out))) for i ∈ axes(out, 1))
istraceless(A::AbstractArray) = all(istraceless(A, dim) for dim ∈ 1:ndims(A))

_issymmetric(A::AbstractArray{<:Any, 0}) = true
_issymmetric(A::AbstractArray{<:Any, 1}) = true
_issymmetric(A::AbstractArray{<:Any, 2}) =
    all(≈(A[i,j] - A[j,i], 0, atol=√(eps(eltype(A)))) for i ∈ axes(A,1), j ∈ axes(A,2))
# _issymmetric(A::AbstractArray, dim) = all(issymmetric(B) for B in eachslice(A, dims=dim))
# _issymmetric(A::AbstractArray) = all(issymmetric(A, dim) for dim in 1:ndims(A))

@testset "Harmonics" begin
    x = normalize(rand(SVector{3,Float64}))
    ê = StdUnitVector{3}
    @testset "Traceless" begin
        for formfield in (sphharm30, sphharm31, sphharm32, sphharm33)
            form = formfield(x)
            K = ndims(form)
            D = Arr.size(form, 1)
            out = SArray(form)
            @test ndims(out) == K
            @test all(==(D), size(out))
            @test istraceless(out)
        end
    end
    @testset "Symmetric" begin
        @test issymmetric(SArray(sphharm32(x)))
        for i ∈ 1:3
            @test _issymmetric(SArray(sphharm33(x)(:,:, ê(i))))
            @test _issymmetric(SArray(sphharm33(x)(:, ê(i), :)))
            # Needed? I think implied by the previous two
            @test _issymmetric(SArray(sphharm33(x)(ê(i), :, :)))
        end
    end
end;
#+end_src

#+RESULTS:
: [0m[1mTest Summary: | [22m[32m[1mPass  [22m[39m[36m[1mTotal  [22m[39m[0m[1mTime[22m
: Harmonics     | [32m  22  [39m[36m   22  [39m[0m0.7s
Lets check the performance of these functions.

#+begin_src jupyter-julia
using BenchmarkTools, StaticArrays

bmarks = let
    n̂ = rand(SVector{3})
    (u, v, w) = ntuple(_ -> round.(normalize(rand(SVector{3})), digits=2), Val(3))

    println("Second order form")
    println("  all components -> 3x3 matrix")
    @btime SArray(sphharm32(n̂[])) setup=(n̂=$(Ref(n̂)))
    println("  single contraction -> length-3 vector  (matrix-vector prodct)")
    @btime SArray(sphharm32(n̂[])(:, v[])) setup=(n̂=$(Ref(n̂)); v=$(Ref(v)))
    println("  double contraction -> scalar  (quadratic form)")
    @btime sphharm32(n̂[])(u[], v[]) setup=(n̂=$(Ref(n̂)); u=$(Ref(u)); v=$(Ref(v)))
    println()

    println("Third order form")
    println("  all components -> 3x3x3 array")
    @btime SArray(sphharm33(n̂[])(:, :, :)) setup=(n̂=$(Ref(n̂));)
    println("  single contraction -> 3x3 matrix")
    @btime SArray(sphharm33(n̂[])(:, :, u[])) setup=(n̂=$(Ref(n̂)); u=$(Ref(u)))
    println("  double contraction -> length-3 vector")
    @btime SArray(sphharm33(n̂[])(:, u[], v[])) setup=(n̂=$(Ref(n̂)); u=$(Ref(u)); v=$(Ref(v)))
    println("  full contraction -> scalar")
    @btime sphharm33(n̂[])(u[], v[], w[]) setup=(n̂=$(Ref(n̂)); u=$(Ref(u)); v=$(Ref(v)); w=$(Ref(w)))
end;
#+end_src

#+RESULTS:
#+begin_example
Second order form
  all components -> 3x3 matrix
  2.793 ns (0 allocations: 0 bytes)
  single contraction -> length-3 vector  (matrix-vector prodct)
  2.305 ns (0 allocations: 0 bytes)
  double contraction -> scalar  (quadratic form)
  3.771 ns (0 allocations: 0 bytes)

Third order form
  all components -> 3x3x3 array11.885 ns (0 allocations: 0 bytes)
  single contraction -> 3x3 matrix33.127 ns (0 allocations: 0 bytes)
  double contraction -> length-3 vector13.226 ns (0 allocations: 0 bytes)
  full contraction -> scalar5.308 ns (0 allocations: 0 bytes)
#+end_example

It seems to be as good as we can expect.


* Stokes-flow hydrodynamics

** Stokes multipoles

How about the all-important (to me) Stokeslet tensor \(S\) in three dimensions?  In the usual index notation,
\[ 8π S_{ij}(\vec x) = \frac{δ_{ij}}{r} + \frac{x_i x_j }{r^3}, \]
where \(\vec x\) is the position vector and \(r = |\vec x|\).
We can also write the Stokeslet at each point as a multilinear function
\[ 8π \left. S(\uvec e, \vec f) \right|_{x} = \frac{\uvec e ⋅ \vec f}{r} + \frac{(\uvec e ⋅ \vec x)(\vec f ⋅ \vec x)}{r^3}, \]
where \(\uvec e\) is a unit vector (in an arbitrary direction) representing the direction of the flow speed that is computed and \(f\) is the point force at the origin.

Thus, we can get the \(ij\)-th component as \(S_{ij}(x) = \left. S(\hat{\vec e}_i, \hat{\vec e}_j) \right|_{x}\).

#+begin_src jupyter-julia
function stokeslet(x)
    # For efficiency, pre-compute quantities depending on position (x) alone.
    # We also reduce division as much as possible in favor multiplication
    # (faster).
    recip_r = inv(norm(x))
    x̂ = x * recip_r
    prefactor = recip_r / 8π

    # Here is the "implementation" function
    _stokeslet(e, f) = ((e⋅f) + (e⋅x̂)*(x̂⋅f)) * prefactor
    # (Compare to the usual index notation.)

    # Now make it a second order multilinear form in three dimensions
    return MultilinearForm{2,3}(_stokeslet)
end
@btime SArray(stokeslet(x)) setup=(x=SVector{3,Float64}(1.,2,3))
#+end_src

#+RESULTS:
:RESULTS:
:   1.396 ns (0 allocations: 0 bytes)
: 3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
:  0.0113936   0.00151914  0.00227871
:  0.00151914  0.0136723   0.00455742
:  0.00227871  0.00455742  0.0174701
:END:

We are left with a matrix of the components of our favorite (symmetric) tensor.
We can also contract the Stokeslet with a (force) vector to give the Stokeslet velocity field at a given point.
#+begin_src jupyter-julia
@btime SArray(stokeslet(x)(:,f)) setup=begin
    x = SVector{3,Float64}(1,2,3) # Position vector
    f = SVector{3,Float64}(3,2,1) # Force vector
end
#+end_src

#+RESULTS:
:RESULTS:
:   6.146 ns (0 allocations: 0 bytes)
: 3-element SVector{3, Float64} with indices SOneTo(3):
:  0.03949766576529538
:  0.036459383783349585
:  0.033421101801403785
:END:

#+begin_src jupyter-julia
let x = normalize(rand(SVector{3}))
    f = normalize(rand(SVector{3}))
    stokeslet(x)(:,f)                   |> showit ∘ SArray
    (stokeslet(x) - stokeslet(x))(:,f)  |> showit ∘ SArray
end
#+end_src

#+RESULTS:
: 3-element SVector{3, Float64} with indices SOneTo(3):
:  0.0550900614961036
:  0.01987703297886065
:  0.029989046413666134
: 3-element SVector{3, Float64} with indices SOneTo(3):
:  0.0
:  0.0
:  0.0

If we use a ~StdUnitVector~ as one of the vectors, we should get the corresponding column/row of the Stokeslet as a matrix.
#+begin_src jupyter-julia
@btime SArray(stokeslet(x)(:,f)) setup=begin
    x = SVector{3,Float64}(1,2,3)
    f = ê{3}(2)  # take second row/col
end
#+end_src

#+RESULTS:
:RESULTS:
:   5.587 ns (0 allocations: 0 bytes)
: 3-element SVector{3, Float64} with indices SOneTo(3):
:  0.0015191409909728994
:  0.013672268918756093
:  0.004557422972918698
:END:

Computational cost is reduced if you contract the Stokeslet with a vector because the "full" matrix is never formed.
Contraction with a unit vector is even cheaper, since it is equivalent to forming just one row of the Stokeslet.
We can even compute just a single component of the velocity as a scalar.
#+begin_src jupyter-julia
@btime stokeslet(x)(e,f) setup=begin
    x = SVector{3,Float64}(1,2,3)
    # Direction of flow diagonally on xy plane
    e = normalize(SVector{3,Float64}(1,1,0))
    f = SVector{3,Float64}(3,2,1)
end
#+end_src

#+RESULTS:
:RESULTS:
:   5.657 ns (0 allocations: 0 bytes)
: 0.053709744814769436
:END:

As it is possible to pick out a row/column, it is also possible to pick out just one component of the Stokeslet by feeding it two ~StdUnitVector~​s.
#+begin_src jupyter-julia
@btime stokeslet(x)(e,f) setup=begin
    x = SVector{3,Float64}(1,2,3)
    e = ê{3}(1)
    f = ê{3}(2)
end
#+end_src

#+RESULTS:
:RESULTS:
:   0.908 ns (0 allocations: 0 bytes)
: 0.0015191409909728994
:END:

Note that, in all cases, most of the computational cost of evaluating a Stokeslet is actually due to computation of the spatial dependence (taking ~norm(x)~, etc.), though this can be somewhat reduced by annotating the definition of ~stokeslet~ with ~@fastmath~.
#+begin_src jupyter-julia
@btime stokeslet(x) setup=(x = SVector{3}(1., 2., 3.));
#+end_src

#+RESULTS:
:   0.908 ns (0 allocations: 0 bytes)

Without all this machinery, the Stokeslet is not too hard to express using facilities from ~Base~ and ~LinearAlgebra~.
#+begin_src jupyter-julia
function stokeslet2(x)
    recip_r = inv(norm(x))
    x̂ = x * recip_r
    prefactor = recip_r / 8π
    (SMatrix{3,3,Float64}(I) .+ x̂ .* x̂') .* prefactor
end
@btime stokeslet2(SVector(1.,2,3))
#+end_src

#+RESULTS:
:RESULTS:
:   0.978 ns (0 allocations: 0 bytes)
: 3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
:  0.0113936   0.00151914  0.00227871
:  0.00151914  0.0136723   0.00455742
:  0.00227871  0.00455742  0.0174701
:END:

Our code is actually a hair faster it seems!

However, the real advantage is mental workload.
To get the matrix-vector product to get the fluid velocity, you can either do the inefficient method of calling the function above and then calling ~dot~, or writing a whole separate function to do things the algorithmically most efficient way.
#+begin_src jupyter-julia
function stokeslet_dot_f(x, f)
    recip_r = inv(norm(x))
    x̂ = x * recip_r
    prefactor = recip_r / 8π
    (f .+ x̂.*(x̂⋅f)) .* prefactor
end
let f = normalize(rand(SVector{3}))
    x = rand(SVector{3})
    @btime stokeslet2($x) * $f  # Less efficient
    @btime stokeslet_dot_f($x, $f)
end
#+end_src

#+RESULTS:
:RESULTS:
:   11.745 ns (0 allocations: 0 bytes)
:   6.565 ns (0 allocations: 0 bytes)
: 3-element SVector{3, Float64} with indices SOneTo(3):
:  0.013356054280542111
:  0.04485924418011487
:  0.04450259546470775
:END:

If we include third order tensors (e.g. stresslets), the ergonomic advantages of ~MultilinearForms~ are significantly more apparent.

#+begin_src jupyter-julia :results silent
stresslet_ang(n̂) = MultilinearForm{3,3}((e1, e2, e3) ->
    3*(n̂⋅e1)*(n̂⋅e2)*(n̂⋅e3) + (e1⋅e2)*(n̂⋅e3) - (e3⋅e1)*(n̂⋅e2) - (e2⋅e3)*(n̂⋅e1))

function stresslet(x)
    recip_r = inv(norm(x))
    _8π = convert(eltype(x), 8) * π
    radial_fn = recip_r^2 / _8π
    n̂ = x * recip_r
    return radial_fn * stresslet_ang(n̂)
    # return MultilinearForm{3,3}((e1, e2, e3) -> radial_fn * angular_fn(e1, e2, e3))
end
#+end_src

#+begin_src jupyter-julia :results scalar
@btime SArray(stresslet(x)(:,f,n) - stresslet(x)(:,n,f)) setup=begin
    e = StdBasis{3}(Real)
    f = normalize(SVector(1,1,1))
    x = SVector(1.,2,3)
    n = e[1]
end
@btime SArray(stresslet_x(:,f,n) - stresslet_x(:,n,f)) setup=begin
    e = StdBasis{3}(Real)
    f = normalize(SVector(1,1,1))
    x = SVector(1.,2,3)
    n = e[1]
    stresslet_x = stresslet(x)
end
#+end_src

#+RESULTS:
:RESULTS:
:   44.868 ns (0 allocations: 0 bytes)
:   20.946 ns (0 allocations: 0 bytes)
: 3-element SVector{3, Float64} with indices SOneTo(3):
:  -0.004385382300375992
:   0.0008770764600751983
:   0.0008770764600751984
:END:

#+begin_src jupyter-julia :results scalar
let
    e = StdBasis{3}(Real)
    f = normalize(SVector(1,1,1))
    x = SVector(1.,2,3)
    n = e[1]
    stresslet_x = stresslet(x)
    @test stresslet_x(:,f,n) - stresslet_x(:,f,n) == (stresslet_x - stresslet_x)(:,f,n)
end
#+end_src

#+RESULTS:
: [32m[1mTest Passed[22m[39m

/Note:/ speed depends somewhat on order of arguments ~n~ and ~f~. It would be cool to someday have something that optimized loop ordering.  (Though maybe that should be left to the compiler.)

#+begin_src jupyter-julia :results silent
function sourcesink(x)
    recip_r = inv(norm(x))
    _4π = convert(eltype(x), 4) * π
    radial_fn = recip_r^3 / _4π
    n̂ = x * recip_r
    angular_fn = MultilinearForm{2,3}((e1, e2) -> 3*(n̂⋅e1)*(n̂⋅e2) - (e1⋅e2))
    return MultilinearForm{2,3}((e1, e2) -> radial_fn * angular_fn(e1, e2))
end

function sourcesink(x, ε)
    recip_r = inv(√(x⋅x + ε*ε))
    _4π = convert(eltype(x), 4) * π
    radial_fn = recip_r^3 / _4π
    n̂ = x * recip_r
    angular_fn = MultilinearForm{2,3}((e1, e2) -> 3*(n̂⋅e1)*(n̂⋅e2) - (e1⋅e2))
    return MultilinearForm{2,3}((e1, e2) -> radial_fn * angular_fn(e1, e2))
end
#+end_src

Rotlet (problems!)

#+begin_src jupyter-julia
using MultilinearMaps.Special: wedge

let e = StdBasis{3}(Real)
    L = rand(SVector{3})
    x = rand(SVector{3})
    wedge3 = MultilinearForm{3,3}(wedge)
    # @btime $L × $x  # control
    # @btime SArray($wedge3(:, $L, $x))   # pretty fast
    # @btime -SArray($wedge3($L, :, $x))  # slower...
    # @btime SArray($wedge3($L, $x, :))   # slower...

    # Problem b/c wedge isn't guaranteed to return the same type
    # if the order of arguments changes
    @testset "Wedge" begin
        @test eltype(wedge3(:,x,:)) == eltype(x)
        @test eltype(wedge3(:,x,x)) == eltype(x)
        @test_broken eltype(wedge3(:,:,x)) == eltype(x)
    end

end
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
#+begin_example
type StdUnitVector has no field dimension

Stacktrace:
 [1] getproperty
   @ ./Base.jl:38 [inlined]
 [2] _wedge
   @ ~/Development/julia/MultilinearMaps/src/exterior.jl:104 [inlined]
 [3] wedge
   @ ~/Development/julia/MultilinearMaps/src/exterior.jl:90 [inlined]
 [4] (AtomicMultilinearMap{3, Tuple{StaticInt{3}, StaticInt{3}, StaticInt{3}}})(impl::typeof(wedge))
   @ MultilinearMaps ~/Development/julia/MultilinearMaps/src/MultilinearMap.jl:61
 [5] (MultilinearForm{3, 3})(f::Function)
   @ MultilinearMaps ~/Development/julia/MultilinearMaps/src/MultilinearMap.jl:7
 [6] top-level scope
   @ In[54]:6
 [7] eval
   @ ./boot.jl:368 [inlined]
 [8] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String)
   @ Base ./loading.jl:1428
#+end_example
:END:

#+begin_src jupyter-julia
using MultilinearMaps.Special: wedge, _wedge

let e = StdBasis{3}(Real)
    L = rand(SVector{3})
    x = rand(SVector{3})
    V = SVector{3,Float64}
    E = StdUnitVector{3,Bool,Int64}
    @code_warntype wedge(e[1], L, x)
    @btime Base.promote_op($wedge, $E, $V, $V)
    @btime typeof(wedge($e[3], $L, $x))
end
#+end_src

#+RESULTS:
:RESULTS:
# [goto error]
: too many parameters for type
:
: Stacktrace:
:  [1] top-level scope
:    @ In[55]:7
:  [2] eval
:    @ ./boot.jl:368 [inlined]
:  [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String)
:    @ Base ./loading.jl:1428
:END:

** Evaluation at multiple points

Stokeslet/stresslet at many points:
#+begin_src jupyter-julia
let n = 10000
    xs = rand(SVector{3,Float64}, n)
    xs_grid = (SVector{3,Float64}(x,y,0) for x in LinRange(-1, 1, 100), y in LinRange(-1, 1, 100))
    fs = rand(SVector{3,Float64}, n)

    ElT_mat = typeof(SArray(stokeslet(first(xs))))
    ElT_vec = typeof(SArray(stokeslet(first(xs))(:, first(fs))))
    buf_mat = Vector{ElT_mat}(undef, n)
    buf_vec = Vector{ElT_vec}(undef, n)
    # buf = @btime Vector{$ElT}(undef, $n)  # alloc time is ~500-600ns

    # Inlining is important here!
    @inline fun(x) = SArray(stokeslet(x))
    @inline fun(x,f) = SArray(stokeslet(x)(:,f))

    @btime SArray(stokeslet(first($xs)))                 # one evaluation
    @btime map!($fun, $buf_mat, $xs)                     # many evalutations
    @btime SArray(stokeslet(first($xs))(:, first($fs)))  # one evaluation
    @btime map!($fun, $buf_vec, $xs, $fs)                # many evalutations
end
#+end_src

** Visualization

#+begin_src jupyter-julia
using CairoMakie

let sb = StdBasis{3}(Real)
    f = sb[1]
    n = sb[2]

    # Makie needs a function in a rather speficic format.
    velfield(x2d) = let x = SVector(x2d[1], x2d[2], 0.)
        # vel3d = SArray(stokeslet(x)(:,f))
        # vel3d = SArray((stresslet(x)(:,f,n)))
        # vel3d = SArray((stresslet(x)(:,n,f) - stresslet(x)(:,f,n)) / 2)
        # vel3d = SArray((stresslet(x)(:,f,f) + stresslet(x)(:,n,n)) / 2)
        vel3d = SArray(sourcesink(x)(:,f))
        Point2f(vel3d[SOneTo(2)])
    end

    # flowspeed(x2d) = norm(velfield(x2d))

    streamplot(velfield, -3..3, -2..2, axis=(;aspect=DataAspect()))
end
#+end_src

* Use case: Stokes plane-boundary images

** Stress-free wall

#+begin_src jupyter-julia
using CairoMakie

# Multilinear map that reflects a vector through a plane normal to n
reflect(n::AbstractVector) = MultilinearForm{2,3}(
    (e1, e2) -> (e1 ⋅ e2) - 2*(e1 ⋅ n)*(n ⋅ e2)  # 𝗜 - 2 𝐧 ⊗ 𝐧
)

let e = StdBasis{3}(Real)
    @test materialize(SArray, reflect( normalize(SVector(0,1,0)) )(:, e[2])) == [0,-1,0]
end

let sb = StdBasis{3}(Real)
    function stokeslet_nostress(x, y, f, n)
        x_refl = materialize(typeof(x), reflect(n)(:, x))
        y_refl = materialize(typeof(y), reflect(n)(:, y))
        f_refl = materialize(typeof(f), reflect(n)(:, f))

        # Force reflected
        u = stokeslet(x - y)(:, f) + stokeslet(x - y_refl)(:, f_refl)

        # Velocity reflected
        v = stokeslet(x - y)(:, f)
        v_img = reflect(n)(:, SArray(stokeslet(x_refl - y)(:, f)))

        @assert u == v + v_img

        return v + v_img
    end

    n = SVector(0., 1, 0)
    y = n
    f = normalize(SVector(1., 1., 0))

    velfield(x2d) = let x = SVector(x2d[1], x2d[2], 0.)
        materialize(Point3f, stokeslet_nostress(x, y, f, n))[SOneTo(2)]
    end

    (fig,ax,p) = streamplot(velfield, -3..3, -2..2, axis=(;aspect=DataAspect()))
    hlines!(ax, 0; color=:black)
    display(fig)
end
#+end_src

** Stokes plane-wall system

#+begin_src jupyter-julia
let 𝐞 = StdBasis{3}(Real)

    function wall_stokeslet(x, y, f, n)
        f_refl = materialize(typeof(f), reflect(n)(:, f))
        y_refl = materialize(typeof(y), reflect(n)(:, y))
        x_refl = materialize(typeof(x), reflect(n)(:, x))

        # Image singularity way
        u = stokeslet(x - y)(:, f)
        u_img = -stokeslet(x - y_refl)(:, f) +
            2*(n⋅y) * stresslet(x - y_refl)(:, n, f_refl) -
            (n⋅y)^2 * sourcesink(x - y_refl)(:, f_refl)

        # Lorentz way
        #   1) swap y <-> x (mind the gradients!)
        #   2) swap force indices <-> velocity indices
        v = u - stokeslet(x_refl - y)(f, :)
        v_img0 = -2*(n⋅x) * stresslet(x_refl - y)(f, n, :) -
            (n⋅x)^2 * sourcesink(x_refl - y)(f, :)
        v_img = reflect(n)(:, v_img0)

        materialize(SArray, v + v_img)
    end

    f = normalize(SVector(1., 1., 0.))  # SVector{3}(𝐞[1])
    n = SVector{3,Float64}(𝐞[2])

    velfield(x2d) = let x = SVector(x2d[1], x2d[2], 0.)
        Point3f( wall_stokeslet(x, n, f, n) )[SOneTo(2)]
    end

    (fig,ax,p) = streamplot(velfield, -3..3, -2..2, axis=(;aspect=DataAspect()))
    hlines!(ax, 0; color=:black)
    display(fig)
end
#+end_src

* The ε map

#+begin_src jupyter-julia
using Test
using MultilinearMaps.Special
using MultilinearMaps.Special: altsigns, swap_1st, swapeach_1st

@testset "Alternating Map" begin
    @testset "0D" begin @test wedge(1) == 1; end
    @testset "1D" begin
        sb = StdBasis{1}(Real)
        @test wedge(sb[1]) === true
        @test wedge([1]) === 1
    end
    @testset "2D" begin
        sb = StdBasis{2}(Real)
        for (ê1, ê2) ∈ Iterators.product((sb[1], [1,0]), (sb[2], [0,1]))
            @test 1 == wedge(ê1, ê2) == -wedge(ê2, ê1)
            @test 0 == wedge(ê1, ê1) == wedge(ê2, ê2)
        end
    end
    @testset "3D" begin
        sb = StdBasis{3}(Real)
        ê = ([1,0,0], [0,1,0], [0,0,1])
        @test 1 == wedge(ê[1], ê[2], ê[3]) == -wedge(ê[1], ê[3], ê[2])
        @test 1 == -wedge(ê[2], ê[1], ê[3]) == wedge(ê[2], ê[3], ê[1])
        @test 1 == wedge(ê[3], ê[1], ê[2]) == -wedge(ê[3], ê[2], ê[1])
        @test 0 == wedge(ê[1], ê[1], ê[2]) == wedge(ê[1], ê[2], ê[2]) == wedge(ê[1], ê[1], ê[1])
        for (ê1, ê2, ê3) ∈ Iterators.product((ê[1], [1,0,0]),
                                         (ê[2], [0,1,0]),
                                         (ê[3], [0,0,1]))
            @test 1 == wedge(ê1, ê2, ê3) == -wedge(ê1, ê3, ê2)
            @test 1 == -wedge(ê2, ê1, ê3) == wedge(ê2, ê3, ê1)
            @test 1 == wedge(ê3, ê1, ê2) == -wedge(ê3, ê2, ê1)
            @test 0 == wedge(ê1, ê1, ê2) == wedge(ê1, ê2, ê2) == wedge(ê2, ê1, ê2)
            @test 0 == wedge(ê1, ê1, ê1) == wedge(ê2, ê2, ê2) == wedge(ê3, ê3, ê3)
        end
    end
end;

# let sb = StdBasis{3}(Real)
#     wedge(sb[3], sb[2], sb[1])
# end
#+end_src

#+begin_src jupyter-julia
let (x,y,z) = ntuple(_ -> rand(SVector{3}), Val(3))
    e = StdBasis{3}(Real)
    wedge(e[3], e[2], e[1])
end
#+end_src


* Tests of internals

#+begin_src jupyter-julia
@testset "Sizes" begin
    SA_like_inner = StaticArray{Tuple{3,3}}
    @test MM._size(SA_like_inner) === MM._size(inner)
    @test MM.samesize(SA_like_inner, inner) === Arr.size(inner) ==
        Arr.known_size(SA_like_inner)
    @test_throws DimensionMismatch MM.samesize(skew, SA_like_inner)
end;
#+end_src

* Directions for development

** Special multilinear maps: Kronecker delta and Levi-Civita symbol
** Reshaping dimensions (changing the number of arguments)
This is like changing the tensor product basis to another of compatible length
** Permuting dimensions (changing the order of arguments)
** Composition? Could you pass a MultilinearMap as an argument to another multilinear map?  What should happen?
Say a map that takes a vector and produces a reflection of it through a plane...


* COMMENT
#  LocalWords:  multilinear bilinear
