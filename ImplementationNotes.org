#+OPTIONS: toc:nil
#+PROPERTY: header-args:jupyter-julia :session DevNotes :kernel julia :eval no-export :async yes :exports both


#+TITLE: Multilinear Forms: Implementation Notes


* Intro

[[https://en.wikipedia.org/wiki/Multilinear_form][Multilinear forms]] map \(K\) \(D\)-dimensional vectors to a scalar quantity.
An important example of a multilinear form is the standard inner product (dot product) of vectors, which is a bilinear form (also called a 2-linear form or a 2nd order multilinear form).
#+begin_src jupyter-julia :results silent
using LinearAlgebra
@inline _inner(v1, v2) = v1 ‚ãÖ v2
@inline _inner(vs::NTuple{2}) = _inner(vs...)
#+end_src
It takes two vectors and produces a scalar.
A \(K\)th order multilinear form \(f\) can be represented in terms of scalar components \(A_{i_1 ‚ãØ i_K\) as
\begin{equation*}
f(v_1, ‚ãØ, v_K) = A_{i_1 ‚ãØ i_K} ‚ãØ v_{1 i_1} ‚ãØ v_{1 i_K}
\end{equation*}
and therefore are often encoded as multidimensional arrays.
For example, the components of the inner product, \(I(v_1, v_2) = v_1 ‚ãÖ v_2 \), correspond to the Kronecker delta \(Œ¥_{ij}\).
However, representing multilinear forms as functions on vectors is also useful and can be more computationally efficient, especially if the tensor \(A\) is not of full rank or can be represented in a particular form.
(For instance, computing an inner product by naively multiplying by the identity matrix by \(v_1\) on the left and \(v_2\) on the right is not very efficient.)
Like general tensors, multilinear forms are invariant under a change of coordinates.

Here is another example of a 4-linear form, which takes four vectors and produces a scalar
#+begin_src jupyter-julia :results silent
@inline _skew(v1, v2, v3, v4) = ((v1‚ãÖv3)*(v2‚ãÖv4) - (v1‚ãÖv4)*(v2‚ãÖv3))
@inline _skew(vs::NTuple{4}) = _skew(vs...)
#+end_src
and has components \(Œ¥_{ik} Œ¥_{jl} - Œ¥_{il} Œ¥_{jk}\).

** Functions on indices

The following functions are similar to ~_inner~ and ~_skew~, but are directly functions of indices rather than vectors.  They are essentially equivalent if one restricts attention to ~v1, ‚ãØ, vN~ being one of the standard unit vectors.
#+begin_src jupyter-julia :results silent
# The Kronecker delta, Œ¥_{ij}, as a function of indices
inner_ixfn(i, j) = (i==j)
@inline inner_ixfn(args::Dims{2}) = inner_ixfn(args...)
@inline inner_ixfn(I::CartesianIndex{2}) = inner_ixfn(Tuple(I)...)

# A 4th order isotropic tensor, Œ¥_{ik} Œ¥_{jl} - Œ¥_{il} Œ¥_{jk}
skew_ixfn(i, j, k, l) = (i==k) * (j==l) - (i==l) * (j==k)
@inline skew_ixfn(args::Dims{4}) = skew_ixfn(args...)
@inline skew_ixfn(I::CartesianIndex{4}) = skew_ixfn(Tuple(I)...)
#+end_src

We can loop over functions like these to fill up an array of tensor components, as demonstrated by the following functions.
#+begin_src jupyter-julia :results silent
using Base.Cartesian

"""
Fill `arr` with function `f` using CartesianIndices()
"""
function fillfn_cartesianindices!(arr, f::F) where F  # force specialization
    for I ‚àà CartesianIndices(arr)
        @inbounds arr[I] = f(I)
    end
    return arr
end

@generated function fillfn_basecartesian!(arr::AbstractArray{<:Any,N}, f::F) where {N,F}
    quote
        @nloops $N i arr begin
            @inbounds (@nref $N arr i) = (@ncall $N f i)
        end
        arr
    end
end

const fillfn! = fillfn_basecartesian!
#+end_src

The first form is more elegant and idiomatic Julia code, but the second, which generates a function with explicit nested loops, is for some reason more performant when the input array to be filled is a ~StaticArrays.MArray~.

#+begin_src jupyter-julia
using BenchmarkTools
using StaticArrays
using StaticArrays: sacollect

let # SDims = NTuple{4,3}
    # dims = fieldtypes(SDims)
    # ixfn = skew_ixfn
    # T = eltype(ixfn(ntuple(_ -> 1, Val(fieldcount(SDims)))))

    println("  Iteration over `CartesianIndices`")
    out1 = @btime(
        fillfn_cartesianindices!(A, $skew_ixfn),
        setup=(A = MArray{NTuple{4,3},Int}(undef))
    )
    println("  Using `Base.Cartesian`")
    out2 = @btime(
        fillfn_basecartesian!(A, $skew_ixfn),
        setup=(A = MArray{NTuple{4,3},Int}(undef))
    )

    println("`SArray` via `sacollect`")
    out3 = @btime(
        sacollect(SArray{NTuple{4,3}}, $skew_ixfn(I) for I ‚àà Is),
        setup=(Is = CartesianIndices(ntuple(_ -> SOneTo(3), Val(4))))
    )

    @assert out1 == out2 == out3
end;
#+end_src

~sacollect~ is most efficient because it effectively unrolls all the loops.
However, using approaches with looping might be beneficial in cases where loop unrolling would create too much work for the compiler.
We will try to sacrifice as little performance over these "baseline" indical functions as possible in our implementation below.


* Unit vectors and indices

There is really no distinction between functions indices, which give the components of a tensor, and multilinear forms on the standard unit vectors because the index \(i\) directly maps over to the unit vector \(e_i\) pointing in the \(i\)th direction.
We therefore define a special type to represent such standard unit vectors.

#+begin_src jupyter-julia :results silent
using LinearAlgebra

import LinearAlgebra: dot
import StaticArrays: same_size, size_tuple, _vecdot
import Base: (==)

# TODO: build these up
abstract type Basis{D} end
struct StandardBasis{D} end
# Could define `iterate` and `getindex` on singleton types <: `StandardBasis{N}
# where N`, to produce the `N` standard unit vectors.  We would also have
# dualbasis(StandardBasis{3}) === StandardBasis{3}()
# Then, we could move to arbitrary sets of basis vectors ...

struct StdUnitVector{D} <: StaticVector{D,Bool}
    direction::Int
    @inline function StdUnitVector{D}(d::Int) where D
        _check_dimensionality(Val(D))
        @boundscheck _check_direction(Val(D), d)
        new(d)
    end
end

# Could also define the notion of a scaled unit vector

@inline _check_dimensionality(::Val{D}) where D =
    D isa Int && D > 0 || _throw_dimensionality_error(D)
@inline _check_direction(::Val{D}, d::Int) where D =
    1 ‚â§ d ‚â§ D || _throw_dims_error(D, d)

@noinline _throw_dimensionality_error(D) =
    throw(DomainError(D, "Number of dimensions `D` must be a positive `Int`"))
@noinline _throw_dims_error(D, d) =
    throw(DomainError(d, "No vector in $(d)th dimension of a basis spanning ‚Ñù^$D"))

"""
Return the `N` standard unit vectors of an `N`-dimensional standard
basis.
"""
basis(::Type{StdUnitVector{N}}) where N =
    ntuple(i -> StdUnitVector{N}(i), Val(N))

"""
    direction(e::StdUnitVector)::Int

Returns an `Int` indicatring the direction in which `e` points.
"""
@inline direction(e::StdUnitVector) = e.direction

# @inline Base.length(::StdUnitVector{D}) where D = D
# @inline Base.size(e::StdUnitVector) = (length(e),)
# Base.IndexStyle(::StdUnitVector) = IndexLinear()

==(es::StdUnitVector...) = ===(es...)

# I read somewhere that @inline is required to ensure that @inbounds works.
@inline function Base.getindex(e::StdUnitVector, i::Int)
    @boundscheck checkbounds(e, i)  # NOTE: uses `size(e)`
    direction(e) == i
end

Base.show(io::IO, e::StdUnitVector{D}) where D = print(io, "ùêû{$D}_$(direction(e))")

# The dot product

@inline dot(e1::StdUnitVector, e2::StdUnitVector) =
    (same_size(e1, e2); e1 === e2)

# @inline dot(e::StdUnitVector{D}, v::StaticVector{D}) where D =
#     (@boundscheck _check_dot(e, v); @inbounds v[direction(e)])

@inline dot(e::StdUnitVector, v::StaticVector) =
    _vecdot(same_size(e, v), e, v, dot)
@inline dot(v::StaticVector, e::StdUnitVector) = dot(e, v)

@inline function _vecdot(sz::Size, a::StdUnitVector, b::StaticArray, ::typeof(dot))
    # eltype(StdUnitVector) == `Bool` so...
    @assert promote_type(eltype(a), eltype(b)) === eltype(b)
    if Length(sz) == 0  # No elements!
        # should be unreachable because there is no zero-dimensional unit vector
        zero(eltype(b))
    else
        @inbounds b[direction(a)]
    end
end

@inline dot(e::StdUnitVector, v::AbstractArray) =
    dot(e, SizedArray{size_tuple(Size(e))}(v))
@inline dot(v::AbstractArray, e::StdUnitVector) = dot(e, v)

# TODO: add specialized arithmetic operations +, -,
# scalar and matrix multiplication (*), etc.

# For example, (+) should spit out a `StaticVector` since the size is known.
# Right now, usual `Array`s are emitted.

#+end_src

Importantly, in the above implementation, taking the dot product of a ~StdUnitVector~ with a "regular" vector just performs indexing, and the dot product of two ~StdUnitVector~‚Äãs amounts to checking if their directions are the same.

Now, if we evaluate ~_inner~ where the all arguments are ~StdUnitVector{N}~‚Äãs (unit vectors in \(\mathbb R^N\)), we really just have a function that tests whether the ~direction~ of each vector is the same.
For example, the dot product between two unit vectors, ~[1, 0, 0]~ and ~[0, 0, 1]~, is reduced to testing whether ~1==3~, which simply evaluates to ~false == 0~.

Below, we use an array comprehension to loop over the unit vectors to produce the \(3√ó3\) identity matrix.
#+begin_src jupyter-julia
let e = basis(StdUnitVector{3})
    [_inner(e[i], e[j]) for j ‚àà eachindex(e), i ‚àà eachindex(e)]
end
#+end_src

** Tests

#+begin_src jupyter-julia
using Test

@testset "Unit Vectors" begin
    # Construction
    @test StdUnitVector{2}(1) isa StaticVector{2,Bool}
    @test length(StdUnitVector{2}(1)) == only(size(StdUnitVector{2}(1)))
    @test_throws DomainError StdUnitVector{2}(3)
    @test_throws DomainError StdUnitVector{1}(0)
    @test only(StdUnitVector{1}(1))
    # Equality testing
    @test StdUnitVector{2}(1) == StdUnitVector{2}(1)
    @test StdUnitVector{2}(1) !== StdUnitVector{2}(2)
    @test StdUnitVector{2}(1) !== StdUnitVector{3}(1)
    @test StdUnitVector{2}(1) == Bool[true, false]
    @test StdUnitVector{2}(1) !== Bool[true, false, false]
    # Dot product
    @test @inferred StdUnitVector{1}(1) ‚ãÖ StdUnitVector{1}(1)
    @test StdUnitVector{2}(1) ‚ãÖ StdUnitVector{2}(1)
    @test !(StdUnitVector{2}(1) ‚ãÖ StdUnitVector{2}(2))
    @test !(StdUnitVector{2}(2) ‚ãÖ StdUnitVector{2}(1))
    @test StdUnitVector{2}(1) ‚ãÖ [1,2] == [1,2] ‚ãÖ StdUnitVector{2}(1) == 1
    @test StdUnitVector{2}(2) ‚ãÖ [1,2] == [1,2] ‚ãÖ StdUnitVector{2}(2) == 2
    @test StdUnitVector{2}(1) ‚ãÖ SVector(1,2) == SVector(1,2) ‚ãÖ StdUnitVector{2}(1) == 1
    @test StdUnitVector{2}(2) ‚ãÖ [1,2] == [1,2] ‚ãÖ StdUnitVector{2}(2) == 2
    @test_throws DimensionMismatch StdUnitVector{2}(1) ‚ãÖ StdUnitVector{1}(1)
    @test_throws DimensionMismatch SVector(1,2) ‚ãÖ StdUnitVector{1}(1)
    @test_throws DimensionMismatch [1,2] ‚ãÖ StdUnitVector{1}(1)
    # Other
    @test StdUnitVector{2}(1) + StdUnitVector{2}(2) === ones(SVector{2,eltype(true+true)})
    @test @inferred(StdUnitVector{2}(2) + [1,0]) == ones(2)
end;
#+end_src

** Performance

We can check for any overhead compared to direct computation on the indices, and there seems to be none.
#+begin_src jupyter-julia
@btime(
    begin for l ‚àà axes(A,4), k ‚àà axes(A,3), j ‚àà axes(A,2), i ‚àà axes(A,1)
        @inbounds A[i,j,k,l] = _skew(StdUnitVector{3}(i), StdUnitVector{3}(j), StdUnitVector{3}(k), StdUnitVector{3}(l))
    end
    A
    end,
    setup=(A = MArray{NTuple{4,3}, Int64}(undef))
);
#+end_src

#+begin_src jupyter-julia :results scalar
@inline inds2uvecs(inds::Vararg{Int}) = map(StdUnitVector{3}, inds)
# @inline inds2uvecs(I::CartesianIndex) = map(StdUnitVector{3}, Tuple(I))
out1 = @btime fillfn_basecartesian!(A, skew_ixfn) setup=(A = MArray{NTuple{4,3},Int64}(undef))
out2 = @btime(fillfn_basecartesian!(A, _skew ‚àò inds2uvecs),
              setup=(A = MArray{NTuple{4,3},Int64}(undef)))
out1 == out2
#+end_src


* Multilinear forms

Below, we define a callable type ~MultilinearForm~ whose instances represent multilinear forms.
~MultilinearForm~ is constructed by passing an "implementation" function like ~_inner~ or ~_skew~.
We'll restrict our attention to the case where the vectors operated on by a given ~MultilinearForm~ are of known spatial dimension (~length~), usually being between 1--4 and most commonly 2 or 3.
Thus, we represent such vectors using types from ~StaticArrays~ for efficiency.

#+begin_src jupyter-julia :results silent
using StaticArrays

abstract type AbstractMultilinearForm{K,D} end

# For now, everything is in Cartesian space
basis(mf::AbstractMultilinearForm{<:Any,D}) where D = basis(StdUnitVector{D})

# Convenient type aliases for passing sets of vectors
const FormArgs{K,D} = NTuple{K,StaticVector{D}}

# Helper method so we aren't forced to wrap arguments in a tuple. Note that the
# `::Vararg{K}` is required or things will infinitely recurse.
(mf::AbstractMultilinearForm{K})(vs::Vararg{Any,K}) where K = mf(vs)

struct MultilinearForm{K,D,F} <: AbstractMultilinearForm{K,D}
    f::F
    MultilinearForm{K,D}(f::F) where {K,D,F} = new{K,D,F}(f)
end

# Call that procudes a scalar value
(mf::MultilinearForm{K,D})(vs::FormArgs{K,D}) where {K,D} =
    mf.f(vs...)

# Dimension of the tensor product of vector spaces that the form works on, i.e.,
# the tensorial order
order(::Type{<:AbstractMultilinearForm{K}}) where K = K
order(::M) where {M<:AbstractMultilinearForm} = order(M)

# Dimension of the vector space for each individual argument
dimension(::Type{<:AbstractMultilinearForm{<:Any,D}}) where D = D
dimension(::M) where {M<:AbstractMultilinearForm} = dimension(M)
# Call that produces a "contracted" form
#+end_src

Check that things work efficiently (no allocations, e.g.).

#+begin_src jupyter-julia :results scalar
using BenchmarkTools
using Test

let u = SVector(1, 0, 0), v = SVector{3}(0, 1, 0)
    inner = MultilinearForm{2,3}(_inner)
    skew = MultilinearForm{4,3}(_skew)
    println("Contraction, form of order $(order(inner)) in $(dimension(inner)) dimensions")
    @assert 1 == @btime($inner($(u,u)))
    println("Contraction, form of order $(order(skew)) in $(dimension(skew)) dimensions")
    @assert 1 == @btime($skew($(u,v,u,v)))
end
#+end_src

We can think of a ~MultilinearForm~ applied to only ~N~ of its ~K~ arguments as a similar multilinear form of order ~K-N~.
We call such a multilinear form "contracted".

#+begin_src jupyter-julia :results silent
const ContractionArgs{K,D} = NTuple{K,Union{StaticVector{D},Colon}}

# Represent a partially contracted form
struct ContractedMultilinearForm{K, D, K‚Ä≤, M<:MultilinearForm{K‚Ä≤,D},
                                 T<:ContractionArgs{K‚Ä≤,D}} <: AbstractMultilinearForm{K,D}
    parent::M
    args::T
    function ContractedMultilinearForm{K,D,K‚Ä≤}(parent::M, args::T) where {K,D,K‚Ä≤,M,T}
        @assert K < K‚Ä≤  # parent must take fewer arguments than contracted form
        new{K,D,K‚Ä≤,M,T}(parent, args)
    end
end

function _contractargs(T::Type{<:ContractedMultilinearForm{K}}) where K
    # We need to intercalate the "concrete" parent arguments with the "free
    # arguments" of the contracted form.
    #
    # Here, we let "vs" be the free arguments and "us" be the parent arguments.
    parent_argTs = fieldtypes(fieldtype(T, :args))
    j = 0
    [parent_argTs[i] === Colon ? :(vs[$(j+=1)]) : :(cmf.args[$i])
     for i ‚àà eachindex(parent_argTs)]
end

# Use @_inline_meta?
@generated function (cmf::ContractedMultilinearForm)(vs::FormArgs)
    :(cmf.parent.f($(_contractargs(cmf)...)))
end


@generated function (mf::MultilinearForm{K,D})(args::ContractionArgs{K,D}) where {K,D}
    # "Dispatch" is controled by where `:`s appear in `args`.
    K‚Ä≤ = count(arg -> arg === Colon, fieldtypes(args))
    if K‚Ä≤ == K  # All arguments are (:), so this is an identity operation
        :(mf)
    elseif K‚Ä≤ < K
        :(ContractedMultilinearForm{$K‚Ä≤, D, K}(mf, args))
    else # should never happen
        :(@assert false)
    end
end

# function (cmf::ContractedMultilinearForm{K})(args::ContractionArgs{K}) where K
#     # Just modify the args passed to the parent appropriately
#     j = 0
#     args‚Ä≤ = map(eachindex ) do i
#         args[i] isa Colon || cmf.args[i] isa Colon ? Colon :
#     end
# end

# IDEA: define a macro @IndexLabels i, j, k ... or use Symbolics variables
struct IndexLabel{S} end
# use like i = IndexLabel{:i}()

#+end_src

We might want more functionality in the future like the ability to transpose arguments or use index like notation where dummy indices indicate sums and free indices indicate components.
Now, for simplicity, we leave that out.

** Tests

#+begin_src jupyter-julia
using Test

@testset "Multilinear Form -> Scalar" begin
    u = StdUnitVector{2}(1) # SVector(1., 0.)
    v = StdUnitVector{2}(2) # SVector(0., 1.)
    inner = @inferred MultilinearForm{2,2}(_inner)
    skew = @inferred MultilinearForm{4,2}(_skew)
    @test inner(u,u) == 1
    @test inner(u,v) == 0
    @test inner(v,u) == 0
    @test skew(u,u,v,v) == 0
    @test skew(u,v,u,v) == 1
    @test skew(u,v,v,u) == -1
end
@testset "Multilinear Form -> Contracted Form" begin
    let
        u = StdUnitVector{2}(1) # SVector(1., 0.)
        v = StdUnitVector{2}(2) # SVector(0., 1.)
        inner = @inferred MultilinearForm{2,2}(_inner)
        @test_throws MethodError inner(:,:,:)
        @test_throws MethodError inner(:)
        @test inner(:,:) === inner
        @inferred inner(u,:)
        @test 1 == inner(u,u) == @inferred inner(u,:)(u) == @inferred inner(:,u)(u)
    end
    let (u,v,w,x) = ntuple(_ -> rand(SVector{3,Float64}), Val(4))
        inner = @inferred MultilinearForm{2,3}(_inner)
        skew = @inferred MultilinearForm{4,3}(_skew)
        @inferred skew(u,v,w,:)
        @inferred skew(u,v,w,:)(x)
        @test inner(u,v) == inner(u,:)(v) == inner(:,u)(v) == inner(:,:)(u,v)
        @test skew(u,v,w,x) ‚âà skew(u,v,w,:)(x) ‚âà skew(u,v,:,:)(w,x) ‚âà
            skew(u,:,:,:)(v,w,x) ‚âà skew(:,v,w,x)(u)
    end
end;
#+end_src

#+begin_src jupyter-julia
let e = basis(StdUnitVector{3})
    v = SVector{3}(1:3)
    inner(e[2], v)
    SArray(inner(v, :))
end
#+end_src


* Interfaces for iteration, indexing, etc.

If we evaluate ~inner~ where the arguments are all unit vectors, we find that we have a lazy representation of the identity tensor, since \(e_i ‚ãÖ e_j = Œ¥_{ij}\) is equivalent to the Kronecker delta (one if \(i=j\) and zero otherwise).
Below, we use an array comprehension to loop over the unit vectors to produce the identity matrix.
#+begin_src jupyter-julia
let e = basis(StdUnitVector{3})
    inner = MultilinearForm{2,3}(_inner)
    [inner(e[i], e[j]) for j ‚àà eachindex(e), i ‚àà eachindex(e)]
end
#+end_src

Some convenience is provided by implementing the [[https://docs.julialang.org/en/v1/manual/interfaces/][iteration and indexing interfaces]] for ~MultilinearForm~‚Äãs.
This will allow us to "collect" a ~MultilinearForm~ into an array container like ~Array~ or ~SArray~ using ~collect~ or ~StaticArrays.sacollect~, respectively.
Indexing is done my converting each index to a corresponding ~StdUnitVector~ like ~mf[i,j,...] = mf(StdUnitVector{3}(i), StdUnitVector{3}(j), ...)~, to provide a convenience shorthand.
The methods necessary to make this work are implemented below.

#+begin_src jupyter-julia :results silent

# Iteration

# NOTE inlining is important to performance here
@inline function Base.iterate(mf::AbstractMultilinearForm)
    # Piggy-back off of iterate(::CartesianIndices)
    (I, state) = iterate(CartesianIndices(mf))
    return (mf[I], state)
end

@inline function Base.iterate(mf::AbstractMultilinearForm{K}, state) where K
    _maybe(iterate(CartesianIndices(mf), state)) do (I‚Ä≤, state‚Ä≤)
        (mf[I‚Ä≤], state‚Ä≤)
    end
end

@inline _maybe(f, arg) = f(arg)
@inline _maybe(f, ::Nothing) = nothing

Base.IteratorSize(::Type{<:AbstractMultilinearForm{K}}) where K = Base.HasShape{K}()

Base.IndexStyle(::Type{<:AbstractMultilinearForm}) = IndexCartesian()
Base.IndexStyle(mf::AbstractMultilinearForm) = Base.IndexStyle(typeof(mf))

@inline Base.eltype(mf::AbstractMultilinearForm) = eltype(first(mf))

@inline Base.size(mf::AbstractMultilinearForm) = Tuple(Size(mf))
@inline Base.size(mf::AbstractMultilinearForm{K,D}, dim::Int) where {K,D} =
    dim ‚àà 1:K ? D : 1

@inline Base.length(mf::AbstractMultilinearForm) = Int(Length(mf))

# Static Array triats

@inline StaticArrays.Size(::Type{<:AbstractMultilinearForm{K,D}}) where {K,D} =
    Size(ntuple(_ -> D, Val(K)))
@inline StaticArrays.Size(mf::AbstractMultilinearForm) = Size(typeof(mf))

@inline StaticArrays.Length(MF::Type{<:AbstractMultilinearForm}) = Length(Size(MF))
@inline StaticArrays.Length(mf::AbstractMultilinearForm) = Length(Size(mf))

# Indexing

Base.CartesianIndices(::AbstractMultilinearForm{K,D}) where {K,D} =
    CartesianIndices(ntuple(_ -> SOneTo(D), Val(K)))

@inline Base.getindex(mf::AbstractMultilinearForm{K,D}, I::Vararg{Int,K}) where {K,D} =
    mf(map(StdUnitVector{D}, I))

@inline Base.getindex(mf::AbstractMultilinearForm{K}, I::CartesianIndex{K}) where K =
    Base.getindex(mf, Tuple(I)...)

@inline Base.firstindex(mf::AbstractMultilinearForm) = Base.first(CartesianIndices(mf))

@inline Base.lastindex(mf::AbstractMultilinearForm) = Base.last(CartesianIndices(mf))
#+end_src

The ~containertype~ function takes a container type ~T~ and a ~MultilinearForm~ and produces a possibly more specific appropriate container type.
It also checks if the given container type is appropriate.
The appropriate size (and element type, if needed) is determined from the ~MultilinearForm~.
We also define methods for ~StaticArrays.similar_type~ and ~Base.similar~ for convenience, which follow the conventions of their behavior as closely as possible.

#+begin_src jupyter-julia :results silent :eval no

# TODO
function containertype end
# containertype(MF::Type{<:StaticArray}, mf::MultilinearForm) = SArray{size_tuple(Size(MF))}
# containertype(MF::Type{<:StaticArray}, mf::MultilinearForm) = SArray{size_tuple(Size(MF))}

StaticArrays.similar_type(MF::Type{<:MultilinearForm}, ElType::Type, S::Size=Size(MF)) =
    similar_type(SArray, ElType, S)

StaticArrays.similar_type(mf::MultilinearForm, ElType::Type=eltype(mf), S::Size=Size(mf)) =
    similar_type(SArray, ElType, S)

StaticArrays.similar_type(mf::MultilinearForm, S::Size=Size(mf)) =
    similar_type(SArray, eltype(mf), S)

Base.similar(MF::Type{<:MultilinearForm}, ElType::Type, S::Size=Size(MF)) =
    similar_type(MArray, ElType, S)

Base.similar(mf::MultilinearForm, ElType::Type=eltype(mf), S::Size=Size(mf)) =
    similar_type(MArray, ElType, S)

Base.similar(mf::MultilinearForm, S::Size=Size(mf)) =
    similar_type(MArray, eltype(mf), S)

Base.similar(mf::MultilinearForm{K}, ::Type{T}, s::Dims) where {K,T} =
    Array{T,K}(undef, s)

Base.similar(mf::MultilinearForm{K}, s::Dims) where {K,T} =
    Array{eltype(mf), K}(undef, s)
#+end_src

Collect into a given container, (implicitly defaulting to a regular ~Array~ if no type argument is passed).
(/Actually, the above methods for ~similar_type~ may not be needed.  Excluding them for now./)

#+begin_src jupyter-julia :results silent
using StaticArrays: sacollect

const inner = MultilinearForm{2,3}(_inner)
const skew = MultilinearForm{4,3}(_skew)

# ARRGH! We be type pirates
# Also, this appears to have a small runtime cost, perhaps to compute `eltype(sized_gen)`
@inline function StaticArrays.sacollect(::Type{SA}, sized_gen) where {SA<:StaticArray}
    SA‚Ä≤ = similar_type(SA, eltype(sized_gen), Size(sized_gen))
    return sacollect(SA‚Ä≤, sized_gen)
end

@inline (::Type{SA})(mf::AbstractMultilinearForm) where {SA<:StaticArray} = sacollect(SA, mf)
#+end_src

Note that it would be nice if ~sacollect~ had a generic method that could handle iterators that possessed a ~Size~ trait without having to specify the size in the type ~SA~.  We have hacked that together above, but maybe something like this should be considered for inclusion in ~StaticArrays~ itself.

Let's define a few ~MultilinearForms~ (in three dimensions) to work on below.
#+begin_src jupyter-julia :results silent
const eÃÇ = StdUnitVector
_just_true() = true
const solo = MultilinearForm{0,3}(_just_true)
const inner = MultilinearForm{2,3}(_inner)
const skew = MultilinearForm{4,3}(_skew)
#+end_src


** Usage

Forming the identity matrix can be done as:
#+begin_src jupyter-julia
collect(inner)
#+end_src

But, since the size of each dimension is usually small, we integrate with ~StaticArrays~.
#+begin_src jupyter-julia :results silent
# Using sacollect
@assert sacollect(SArray, skew) == sacollect(MArray, skew)
# Using constructors
@assert SArray(skew) == MArray(skew)
#+end_src

** Collection routines

We can collect after contraction / "slicing", too.
#+begin_src jupyter-julia :results silent
@assert SArray(skew)[:,:,3,2] == SArray(skew(:,:, eÃÇ{3}(3), eÃÇ{3}(2)))
#+end_src

Let's make a functions dumping components into an arbitrary container.
#+begin_src jupyter-julia :eval no
function components!(tgt::AbstractArray, mf::MultilinearForm)
    same_size(mf, tgt)
    _unsafe_fill_components!(tgt, mf)
end

@generated function _unsafe_fill_components!(tgt::AbstractArray{<:Any,K}, mf::MultilinearForm{K}) where K
    # @inbounds this when ready to make this not safe
    quote
        @nloops $K i tgt begin
            (@nref $K tgt i) = (@nref $K mf i)
        end
        tgt
    end
end
#+end_src

#+begin_src jupyter-julia :eval no
@btime components!(A, mf) setup=begin
    mf = MultilinearForm{4,3}(_skew)
    A = MArray{NTuple{4,3}, eltype(mf)}(undef)
end;
#+end_src

** Known issues

For some reason, type aliases of ~SArray~ like ~SMatrix~ don't work.
#+begin_src jupyter-julia
SMatrix(inner)  # FIXME: this makes to do but is broken.
#+end_src

** Tests

#+begin_src jupyter-julia :eval no
let D = 3
    inner = MultilinearForm{2,D}(_inner)
    skew = MultilinearForm{4,D}(_skew)
    solo = MultilinearForm{0,D}(() -> 1.0)
    e = basis(StdUnitVector{D})
    @btime StaticArrays.sacollect(SArray{Tuple{}}, $solo)
    @btime StaticArrays.sacollect(SMatrix{3,3}, $skew(:, $e[2], :, $e[3]))
end
#+end_src

#+begin_src jupyter-julia
let u = SVector{3}(1:3), v = SVector{3}(3:-1:1)
    @btime SArray(MultilinearForm{4,3}(_skew))
    out1 = @btime SArray(skew)[:,:,3,2]
    out2 = @btime SArray(skew(:,:, eÃÇ{3}(3), eÃÇ{3}(2)))
    @test out1 == out2
end
#+end_src




* Collection into arrays

Spatially dependent stuff.

#+begin_src jupyter-julia :results silent
struct SphericalHarmonic{UV<:StaticVector{<:Any,<:AbstractFloat}}
    xÃÇ::UV
end

# @inline (œï::SphericalHarmonic{3,0}) = MultilinearForm{0,3}(() -> 1.0)
# @inline (œï::SphericalHarmonic{3,1}) = MultilinearForm{1,3}(v -> œï.xÃÇ ‚ãÖ v)
# @inline (œï::SphericalHarmonic{3,2})(v1,v2) = œï(v1) * œï(v2) - (v1‚ãÖv2) / 3
# @inline (œï::SphericalHarmonic{3,3})(v1,v2,v3) =
#     œï(v1)*œï(v2)*œï(v3) - (œï(v1)*(v2‚ãÖv3) + œï(v2)*(v1‚ãÖv3) + œï(v3)*(v1‚ãÖv2)) / 5
#+end_src
