#+OPTIONS: toc:nil
#+PROPERTY: header-args:jupyter-julia :session DevNotes :kernel julia :eval no-export :async yes :exports both


#+TITLE: Multilinear Forms: Implementation Notes


* Introduction

[[https://en.wikipedia.org/wiki/Multilinear_form][Multilinear forms]] map \(K\) \(D\)-dimensional vectors to a scalar quantity.
An important example of a multilinear form is the standard inner product (dot product) of vectors, which is a bilinear form (also called a 2-linear form or a 2nd order multilinear form).
#+begin_src jupyter-julia :results silent
using LinearAlgebra
@inline _inner(v1, v2) = v1 ‚ãÖ v2
@inline _inner(vs::NTuple{2}) = _inner(vs...)
#+end_src
It takes two vectors and produces a scalar.
A \(K\)th order multilinear form \(f\) can be represented in terms of scalar components \(A_{i_1 ‚ãØ i_K\) as
\begin{equation*}
f(v_1, ‚ãØ, v_K) = A_{i_1 ‚ãØ i_K} ‚ãØ v_{1 i_1} ‚ãØ v_{1 i_K}
\end{equation*}
and therefore are often encoded as multidimensional arrays.
For example, the components of the inner product, \(I(v_1, v_2) = v_1 ‚ãÖ v_2 \), correspond to the Kronecker delta \(Œ¥_{ij}\).
However, representing multilinear forms as functions on vectors is also useful and can be more computationally efficient, especially if the tensor \(A\) is not of full rank or can be represented in a particular form.
(For instance, computing an inner product by naively multiplying by the identity matrix by \(v_1\) on the left and \(v_2\) on the right is not very efficient.)
Like general tensors, multilinear forms are invariant under a change of coordinates.

Here is another example of a 4-linear form, which takes four vectors and produces a scalar
#+begin_src jupyter-julia :results silent
@inline _skew(v1, v2, v3, v4) = ((v1‚ãÖv3)*(v2‚ãÖv4) - (v1‚ãÖv4)*(v2‚ãÖv3))
@inline _skew(vs::NTuple{4}) = _skew(vs...)
#+end_src
and has components \(Œ¥_{ik} Œ¥_{jl} - Œ¥_{il} Œ¥_{jk}\).

** Functions on indices

The following functions are similar to ~_inner~ and ~_skew~, but are directly functions of indices rather than vectors.  They are essentially equivalent if one restricts attention to ~v1, ‚ãØ, vN~ being one of the standard unit vectors.
#+begin_src jupyter-julia :results silent
# The Kronecker delta, Œ¥_{ij}, as a function of indices
inner_ixfn(i, j) = (i==j)
@inline inner_ixfn(args::Dims{2}) = inner_ixfn(args...)
@inline inner_ixfn(I::CartesianIndex{2}) = inner_ixfn(Tuple(I)...)

# A 4th order isotropic tensor, Œ¥_{ik} Œ¥_{jl} - Œ¥_{il} Œ¥_{jk}
skew_ixfn(i, j, k, l) = (i==k) * (j==l) - (i==l) * (j==k)
@inline skew_ixfn(args::Dims{4}) = skew_ixfn(args...)
@inline skew_ixfn(I::CartesianIndex{4}) = skew_ixfn(Tuple(I)...)
#+end_src

We can loop over functions like these to fill up an array of tensor components, as demonstrated by the following functions.
#+begin_src jupyter-julia :results silent
using Base.Cartesian

"""
Fill `arr` with function `f` using CartesianIndices()
"""
function fillfn_cartesianindices!(arr, f::F) where F  # force specialization
    for I ‚àà CartesianIndices(arr)
        @inbounds arr[I] = f(I)
    end
    return arr
end

@generated function fillfn_basecartesian!(arr::AbstractArray{<:Any,N}, f::F) where {N,F}
    quote
        @nloops $N i arr begin
            @inbounds (@nref $N arr i) = (@ncall $N f i)
        end
        arr
    end
end

const fillfn! = fillfn_basecartesian!
#+end_src

The first form is more elegant and idiomatic Julia code, but the second, which generates a function with explicit nested loops, is for some reason more performant when the input array to be filled is a ~StaticArrays.MArray~.

#+begin_src jupyter-julia
using BenchmarkTools
using StaticArrays
using StaticArrays: sacollect

let # SDims = NTuple{4,3}
    # dims = fieldtypes(SDims)
    # ixfn = skew_ixfn
    # T = eltype(ixfn(ntuple(_ -> 1, Val(fieldcount(SDims)))))

    println("  Iteration over `CartesianIndices`")
    out1 = @btime(
        fillfn_cartesianindices!(A, $skew_ixfn),
        setup=(A = MArray{NTuple{4,3},Int}(undef))
    )
    println("  Using `Base.Cartesian`")
    out2 = @btime(
        fillfn_basecartesian!(A, $skew_ixfn),
        setup=(A = MArray{NTuple{4,3},Int}(undef))
    )

    println("`SArray` via `sacollect`")
    out3 = @btime(
        sacollect(SArray{NTuple{4,3}}, $skew_ixfn(I) for I ‚àà Is),
        setup=(Is = CartesianIndices(ntuple(_ -> SOneTo(3), Val(4))))
    )

    @assert out1 == out2 == out3
end;
#+end_src

~sacollect~ is most efficient because it effectively unrolls all the loops.
However, using approaches with looping might be beneficial in cases where loop unrolling would create too much work for the compiler.
We will try to sacrifice as little performance over these "baseline" indical functions as possible in our implementation below.


* Unit vectors and indices

There is really no distinction between functions indices, which give the components of a tensor, and multilinear forms on the standard unit vectors because the index \(i\) directly maps over to the unit vector \(e_i\) pointing in the \(i\)th direction.
We therefore define a special type to represent such standard unit vectors.

#+begin_src jupyter-julia :results silent
using LinearAlgebra

import LinearAlgebra: dot
import StaticArrays: same_size, size_tuple, _vecdot
import Base: (==)

# TODO: build these up
abstract type Basis{D} end
struct StandardBasis{D} end
# Could define `iterate` and `getindex` on singleton types <: `StandardBasis{N}
# where N`, to produce the `N` standard unit vectors.  We would also have
# dualbasis(StandardBasis{3}) === StandardBasis{3}()
# Then, we could work with to arbitrary sets of basis vectors ...

# Types to flag safe and unsafe methods
struct Safe end;   const SAFE = Safe()
struct Unsafe end; const UNSAFE = Unsafe()
# Methods marked `UNSAFE` may produce unpredictable behavior
const Safety = Union{Safe,Unsafe}

struct StdUnitVector{D} <: StaticVector{D,Bool}
    direction::Int
    @inline function StdUnitVector{D}(::Unsafe, d::Int) where D
        D isa Int && D > 0 || _throw_dimensionality_error(D)
        new(d)
    end
end
# Could also define the notion of a scaled unit vector

@inline function StdUnitVector{D}(::Safe, d::Int) where D
    1 ‚â§ d ‚â§ D || _throw_dims_error(D, d)
    StdUnitVector{D}(UNSAFE, d::Int)
end

@inline StdUnitVector{D}(d::Int) where D = StdUnitVector{D}(SAFE, d::Int)


# @inline _check_dimensionality(::Val{D}) where D =
#     D isa Int && D > 0 || _throw_dimensionality_error(D)
# @inline _check_direction(::Val{D}, d::Int) where D =
#     1 ‚â§ d ‚â§ D || _throw_dims_error(D, d)

@noinline _throw_dimensionality_error(D) =
    throw(DomainError(D, "Number of dimensions `D` must be a positive `Int`"))
@noinline _throw_dims_error(D, d) =
    throw(DomainError(d, "No vector in $(d)th dimension of a basis spanning ‚Ñù^$D"))

"""
Return the `N` standard unit vectors of an `N`-dimensional standard
basis.
"""
basis(::Type{StdUnitVector{N}}) where N =
    ntuple(i -> StdUnitVector{N}(i), Val(N))

"""
    direction(e::StdUnitVector)::Int

Returns an `Int` indicatring the direction in which `e` points.
"""
@inline direction(e::StdUnitVector) = e.direction

# @inline Base.length(::StdUnitVector{D}) where D = D
# @inline Base.size(e::StdUnitVector) = (length(e),)
# Base.IndexStyle(::StdUnitVector) = IndexLinear()

==(es::StdUnitVector...) = ===(es...)

# I read somewhere that @inline is required to ensure that @inbounds works.
@inline function Base.getindex(e::StdUnitVector, i::Int)
    @boundscheck checkbounds(e, i)  # NOTE: uses `size(e)`
    direction(e) == i
end

Base.show(io::IO, e::StdUnitVector{D}) where D = print(io, "ùêû{$D}_$(direction(e))")

# The dot product

@inline dot(e1::StdUnitVector, e2::StdUnitVector) =
    (same_size(e1, e2); e1 === e2)

# @inline dot(e::StdUnitVector{D}, v::StaticVector{D}) where D =
#     (@boundscheck _check_dot(e, v); @inbounds v[direction(e)])

@inline dot(e::StdUnitVector, v::StaticVector) =
    _vecdot(same_size(e, v), e, v, dot)
@inline dot(v::StaticVector, e::StdUnitVector) = dot(e, v)

@inline function _vecdot(sz::Size, a::StdUnitVector, b::StaticArray, ::typeof(dot))
    # eltype(StdUnitVector) == `Bool` so...
    @assert promote_type(eltype(a), eltype(b)) === eltype(b)
    if Length(sz) == 0  # No elements!
        # should be unreachable because there is no zero-dimensional unit vector
        zero(eltype(b))
    else
        @inbounds b[direction(a)]
    end
end

@inline dot(e::StdUnitVector, v::AbstractArray) =
    dot(e, SizedArray{size_tuple(Size(e))}(v))
@inline dot(v::AbstractArray, e::StdUnitVector) = dot(e, v)

# TODO: add specialized arithmetic operations +, -,
# scalar and matrix multiplication (*), etc.

# For example, (+) should spit out a `StaticVector` since the size is known.
# Right now, usual `Array`s are emitted.

#+end_src

Importantly, in the above implementation, taking the dot product of a ~StdUnitVector~ with a "regular" vector just performs indexing, and the dot product of two ~StdUnitVector~‚Äãs amounts to checking if their directions are the same.

Now, if we evaluate ~_inner~ where the all arguments are ~StdUnitVector{N}~‚Äãs (unit vectors in \(\mathbb R^N\)), we really just have a function that tests whether the ~direction~ of each vector is the same.
For example, the dot product between two unit vectors, ~[1, 0, 0]~ and ~[0, 0, 1]~, is reduced to testing whether ~1==3~, which simply evaluates to ~false == 0~.

Below, we use an array comprehension to loop over the unit vectors to produce the \(3√ó3\) identity matrix.
#+begin_src jupyter-julia
let e = basis(StdUnitVector{3})
    [_inner(e[i], e[j]) for j ‚àà eachindex(e), i ‚àà eachindex(e)]
end
#+end_src

** Tests

#+begin_src jupyter-julia
using Test

@testset "Unit Vectors" begin
    # Construction
    @test StdUnitVector{2}(1) isa StaticVector{2,Bool}
    @test length(StdUnitVector{2}(1)) == only(size(StdUnitVector{2}(1)))
    @test_throws DomainError StdUnitVector{2}(3)
    @test_throws DomainError StdUnitVector{1}(0)
    @test only(StdUnitVector{1}(1))
    # Equality testing
    @test StdUnitVector{2}(1) == StdUnitVector{2}(1)
    @test StdUnitVector{2}(1) !== StdUnitVector{2}(2)
    @test StdUnitVector{2}(1) !== StdUnitVector{3}(1)
    @test StdUnitVector{2}(1) == Bool[true, false]
    @test StdUnitVector{2}(1) !== Bool[true, false, false]
    # Dot product
    @test @inferred StdUnitVector{1}(1) ‚ãÖ StdUnitVector{1}(1)
    @test StdUnitVector{2}(1) ‚ãÖ StdUnitVector{2}(1)
    @test !(StdUnitVector{2}(1) ‚ãÖ StdUnitVector{2}(2))
    @test !(StdUnitVector{2}(2) ‚ãÖ StdUnitVector{2}(1))
    @test StdUnitVector{2}(1) ‚ãÖ [1,2] == [1,2] ‚ãÖ StdUnitVector{2}(1) == 1
    @test StdUnitVector{2}(2) ‚ãÖ [1,2] == [1,2] ‚ãÖ StdUnitVector{2}(2) == 2
    @test StdUnitVector{2}(1) ‚ãÖ SVector(1,2) == SVector(1,2) ‚ãÖ StdUnitVector{2}(1) == 1
    @test StdUnitVector{2}(2) ‚ãÖ [1,2] == [1,2] ‚ãÖ StdUnitVector{2}(2) == 2
    @test_throws DimensionMismatch StdUnitVector{2}(1) ‚ãÖ StdUnitVector{1}(1)
    @test_throws DimensionMismatch SVector(1,2) ‚ãÖ StdUnitVector{1}(1)
    @test_throws DimensionMismatch [1,2] ‚ãÖ StdUnitVector{1}(1)
    # Other
    @test StdUnitVector{2}(1) + StdUnitVector{2}(2) === ones(SVector{2,eltype(true+true)})
    @test @inferred(StdUnitVector{2}(2) + [1,0]) == ones(2)
end;
#+end_src

** Performance

We can check for any overhead compared to direct computation on the indices, and there seems to be none.
#+begin_src jupyter-julia :results scalar
@inline inds2uvecs(safety::S, inds::Vararg{Int}) where {S<:Safety} = map(i -> StdUnitVector{3}(safety, i), inds)
@inline inds2uvecs(safety::S) where {S<:Safety} = (inds...) -> inds2uvecs(safety, inds...)
# @inline inds2uvecs(I::CartesianIndex) = map(StdUnitVector{3}, Tuple(I))
out1 = @btime fillfn_basecartesian!(A, skew_ixfn) setup=(A = MArray{NTuple{4,3},Int64}(undef))
out2 = @btime(fillfn_basecartesian!(A, _skew ‚àò inds2uvecs(UNSAFE)),
              setup=(A = MArray{NTuple{4,3},Int64}(undef)))
out1 == out2
#+end_src

Interestingly, completely explicit loops are little faster, but why?

#+begin_src jupyter-julia
@btime(
    begin for l ‚àà axes(A,4), k ‚àà axes(A,3), j ‚àà axes(A,2), i ‚àà axes(A,1)
        @inbounds A[i,j,k,l] = _skew(StdUnitVector{3}(UNSAFE, i), StdUnitVector{3}(UNSAFE, j),
                                     StdUnitVector{3}(UNSAFE, k), StdUnitVector{3}(UNSAFE, l))
    end
    A
    end,
    setup=(A = MArray{NTuple{4,3}, Int64}(undef))
);
#+end_src


* Multilinear forms

Below, we define a callable type ~MultilinearForm~ whose instances represent multilinear forms.
~MultilinearForm~ is constructed by passing an "implementation" function like ~_inner~ or ~_skew~.
We'll restrict our attention to the case where the vectors operated on by a given ~MultilinearForm~ are of known spatial dimension (~length~), usually being between 1--4 and most commonly 2 or 3.
Thus, we represent such vectors using types from ~StaticArrays~ for efficiency.

#+begin_src jupyter-julia :results silent
using StaticArrays

abstract type AbstractMultilinearForm{K,D} end

# For now, everything is in Cartesian space
basis(mf::AbstractMultilinearForm{<:Any,D}) where D = basis(StdUnitVector{D})

# Convenient type aliases for passing sets of vectors
const FormArgs{K,D} = NTuple{K,StaticVector{D}}

# Helper method so we aren't forced to wrap arguments in a tuple. Note that the
# `::Vararg{K}` is required or things will infinitely recurse.
(mf::AbstractMultilinearForm{K})(vs::Vararg{Any,K}) where K = mf(vs)

struct MultilinearForm{K,D,F} <: AbstractMultilinearForm{K,D}
    f::F
    MultilinearForm{K,D}(f::F) where {K,D,F} = new{K,D,F}(f)
end

# Call that procudes a scalar value
(mf::MultilinearForm{K,D})(vs::FormArgs{K,D}) where {K,D} =
    mf.f(vs...)

# Dimension of the tensor product of vector spaces that the form works on, i.e.,
# the tensorial order
order(::Type{<:AbstractMultilinearForm{K}}) where K = K
order(::M) where {M<:AbstractMultilinearForm} = order(M)

# Dimension of the vector space for each individual argument
dimension(::Type{<:AbstractMultilinearForm{<:Any,D}}) where D = D
dimension(::M) where {M<:AbstractMultilinearForm} = dimension(M)
# Call that produces a "contracted" form
#+end_src

Check that things work efficiently (no allocations, e.g.).

#+begin_src jupyter-julia :results scalar
using BenchmarkTools
using Test

let u = SVector(1, 0, 0), v = SVector{3}(0, 1, 0)
    inner = MultilinearForm{2,3}(_inner)
    skew = MultilinearForm{4,3}(_skew)
    println("Contraction, form of order $(order(inner)) in $(dimension(inner)) dimensions")
    @assert 1 == @btime($inner($(u,u)))
    println("Contraction, form of order $(order(skew)) in $(dimension(skew)) dimensions")
    @assert 1 == @btime($skew($(u,v,u,v)))
end
#+end_src

We can think of a ~MultilinearForm~ applied to only ~N~ of its ~K~ arguments as a similar multilinear form of order ~K-N~.
We call such a multilinear form "contracted".

#+begin_src jupyter-julia :results silent
const ContractionArgs{K,D} = NTuple{K,Union{StaticVector{D},Colon}}

# Represent a partially contracted form
struct ContractedMultilinearForm{K, D, K‚Ä≤, M<:MultilinearForm{K‚Ä≤,D},
                                 T<:ContractionArgs{K‚Ä≤,D}} <: AbstractMultilinearForm{K,D}
    parent::M
    args::T
    function ContractedMultilinearForm{K,D,K‚Ä≤}(parent::M, args::T) where {K,D,K‚Ä≤,M,T}
        @assert K < K‚Ä≤  # parent must take fewer arguments than contracted form
        new{K,D,K‚Ä≤,M,T}(parent, args)
    end
end

function _contractargs(T::Type{<:ContractedMultilinearForm{K}}) where K
    # We need to intercalate the "concrete" parent arguments with the "free
    # arguments" of the contracted form.
    #
    # Here, we let "vs" be the free arguments and "us" be the parent arguments.
    parent_argTs = fieldtypes(fieldtype(T, :args))
    j = 0
    [parent_argTs[i] === Colon ? :(vs[$(j+=1)]) : :(cmf.args[$i])
     for i ‚àà eachindex(parent_argTs)]
end

# Use @_inline_meta?
@generated function (cmf::ContractedMultilinearForm)(vs::FormArgs)
    :(cmf.parent.f($(_contractargs(cmf)...)))
end


@generated function (mf::MultilinearForm{K,D})(args::ContractionArgs{K,D}) where {K,D}
    # "Dispatch" is controled by where `:`s appear in `args`.
    K‚Ä≤ = count(arg -> arg === Colon, fieldtypes(args))
    if K‚Ä≤ == K  # All arguments are (:), so this is an identity operation
        :(mf)
    elseif K‚Ä≤ < K
        :(ContractedMultilinearForm{$K‚Ä≤, D, K}(mf, args))
    else # should never happen
        :(@assert false)
    end
end

# function (cmf::ContractedMultilinearForm{K})(args::ContractionArgs{K}) where K
#     # Just modify the args passed to the parent appropriately
#     j = 0
#     args‚Ä≤ = map(eachindex ) do i
#         args[i] isa Colon || cmf.args[i] isa Colon ? Colon :
#     end
# end

# IDEA: define a macro @IndexLabels i, j, k ... or use Symbolics variables
struct IndexLabel{S} end
# use like i = IndexLabel{:i}()

#+end_src

We might want more functionality in the future like the ability to transpose arguments or use index like notation where dummy indices indicate sums and free indices indicate components.
Now, for simplicity, we leave that out.

Let's define a few ~MultilinearForms~ (in three dimensions) to work on below.
#+begin_src jupyter-julia :results silent
const eÃÇ = StdUnitVector
_just_true() = true
const solo = MultilinearForm{0,3}(_just_true)
const inner = MultilinearForm{2,3}(_inner)
const skew = MultilinearForm{4,3}(_skew)
#+end_src

** Tests

#+begin_src jupyter-julia
using Test

@testset "Multilinear Form -> Scalar" begin
    u = StdUnitVector{2}(1) # SVector(1., 0.)
    v = StdUnitVector{2}(2) # SVector(0., 1.)
    solo = @inferred MultilinearForm{0,3}(_just_true)
    inner = @inferred MultilinearForm{2,2}(_inner)
    skew = @inferred MultilinearForm{4,2}(_skew)
    @test inner(u,u) == 1
    @test inner(u,v) == 0
    @test inner(v,u) == 0
    @test skew(u,u,v,v) == 0
    @test skew(u,v,u,v) == 1
    @test skew(u,v,v,u) == -1
end
@testset "Multilinear Form -> Contracted Form" begin
    let
        u = StdUnitVector{2}(1) # SVector(1., 0.)
        v = StdUnitVector{2}(2) # SVector(0., 1.)
        inner = @inferred MultilinearForm{2,2}(_inner)
        @test_throws MethodError inner(:,:,:)
        @test_throws MethodError inner(:)
        @test inner(:,:) === inner
        @inferred inner(u,:)
        @test 1 == inner(u,u) == @inferred inner(u,:)(u) == @inferred inner(:,u)(u)
    end
    let (u,v,w,x) = ntuple(_ -> rand(SVector{3,Float64}), Val(4))
        inner = @inferred MultilinearForm{2,3}(_inner)
        skew = @inferred MultilinearForm{4,3}(_skew)
        @inferred skew(u,v,w,:)
        @inferred skew(u,v,w,:)(x)
        @test inner(u,v) == inner(u,:)(v) == inner(:,u)(v) == inner(:,:)(u,v)
        @test skew(u,v,w,x) ‚âà skew(u,v,w,:)(x) ‚âà skew(u,v,:,:)(w,x) ‚âà
            skew(u,:,:,:)(v,w,x) ‚âà skew(:,v,w,x)(u)
    end
end;
#+end_src


* Interfaces for iteration, indexing, etc.

If we evaluate ~inner~ where the arguments are all unit vectors, we find that we have a lazy representation of the identity tensor, since \(e_i ‚ãÖ e_j = Œ¥_{ij}\) is equivalent to the Kronecker delta (one if \(i=j\) and zero otherwise).
Below, we use an array comprehension to loop over the unit vectors to produce the identity matrix.
#+begin_src jupyter-julia
let e = basis(StdUnitVector{3})
    inner = MultilinearForm{2,3}(_inner)
    [inner(e[i], e[j]) for j ‚àà eachindex(e), i ‚àà eachindex(e)]
end
#+end_src

Some convenience is provided by implementing the [[https://docs.julialang.org/en/v1/manual/interfaces/][iteration and indexing interfaces]] for ~MultilinearForm~‚Äãs.
This will allow us to "collect" a ~MultilinearForm~ into an array container like ~Array~ or ~SArray~ using ~collect~ or ~StaticArrays.sacollect~, respectively.
Indexing is done my converting each index to a corresponding ~StdUnitVector~ like ~mf[i,j,...] = mf(StdUnitVector{3}(i), StdUnitVector{3}(j), ...)~, to provide a convenience shorthand.
The methods necessary to make this work are implemented below.

#+begin_src jupyter-julia :results silent

# Iteration

# NOTE inlining is important to performance here
@inline function Base.iterate(mf::AbstractMultilinearForm)
    # Piggy-back off of iterate(::CartesianIndices)
    (I, state) = iterate(CartesianIndices(mf))
    return (unsafe_getindex(mf, I), state)
    #   -> (mf[I], state)
    # Should be safe to elide the unit vector validity check
end

@inline function Base.iterate(mf::AbstractMultilinearForm{K}, state) where K
    _maybe(iterate(CartesianIndices(mf), state)) do (I‚Ä≤, state‚Ä≤)
        (unsafe_getindex(mf, I‚Ä≤), state‚Ä≤)
    end
end

@inline _maybe(f, arg) = f(arg)
@inline _maybe(f, ::Nothing) = nothing

Base.IteratorSize(::Type{<:AbstractMultilinearForm{K}}) where K = Base.HasShape{K}()

Base.IndexStyle(::Type{<:AbstractMultilinearForm}) = IndexCartesian()
Base.IndexStyle(mf::AbstractMultilinearForm) = Base.IndexStyle(typeof(mf))

@inline Base.eltype(mf::AbstractMultilinearForm) = eltype(first(mf))

@inline Base.size(mf::AbstractMultilinearForm) = Tuple(Size(mf))
@inline Base.size(mf::AbstractMultilinearForm{K,D}, dim::Int) where {K,D} =
    dim ‚àà 1:K ? D : 1

@inline Base.length(mf::AbstractMultilinearForm) = Int(Length(mf))

# Static Array triats

@inline StaticArrays.Size(::Type{<:AbstractMultilinearForm{K,D}}) where {K,D} =
    Size(ntuple(_ -> D, Val(K)))
@inline StaticArrays.Size(mf::AbstractMultilinearForm) = Size(typeof(mf))

@inline StaticArrays.Length(MF::Type{<:AbstractMultilinearForm}) = Length(Size(MF))
@inline StaticArrays.Length(mf::AbstractMultilinearForm) = Length(Size(mf))

# Indexing

Base.CartesianIndices(::AbstractMultilinearForm{K,D}) where {K,D} =
    CartesianIndices(ntuple(_ -> SOneTo(D), Val(K)))

@inline Base.getindex(mf::AbstractMultilinearForm{K,D}, I::Vararg{Int,K}) where {K,D} =
    mf(map(StdUnitVector{D}, I))

@inline Base.getindex(mf::AbstractMultilinearForm{K}, I::CartesianIndex{K}) where K =
    Base.getindex(mf, Tuple(I)...)

@inline Base.firstindex(mf::AbstractMultilinearForm) = Base.first(CartesianIndices(mf))

@inline Base.lastindex(mf::AbstractMultilinearForm) = Base.last(CartesianIndices(mf))

# UNSAFE indexing; do not check for validitiy of the StdUnitVectors in each direction

@inline unsafe_getindex(mf::AbstractMultilinearForm{K,D}, I::Vararg{Int,K}) where {K,D} =
    mf(map(i -> StdUnitVector{D}(UNSAFE, i), I))

@inline unsafe_getindex(mf::AbstractMultilinearForm{K}, I::CartesianIndex{K}) where K =
    unsafe_getindex(mf, Tuple(I)...)
#+end_src

We define methods for ~StaticArrays.similar_type~ and ~Base.similar~ for convenience, which follow the conventions of their behavior as closely as possible.

#+begin_src jupyter-julia :results silent

StaticArrays.similar_type(MF::Type{<:AbstractMultilinearForm}, ElType::Type, S::Size=Size(MF)) =
    similar_type(StaticArray, ElType, S)

StaticArrays.similar_type(mf::AbstractMultilinearForm, ElType::Type=eltype(mf), S::Size=Size(mf)) =
    similar_type(StaticArray, ElType, S)

StaticArrays.similar_type(mf::AbstractMultilinearForm, S::Size=Size(mf)) =
    similar_type(StaticArray, eltype(mf), S)

Base.similar(MF::Type{<:AbstractMultilinearForm}, ElType::Type, S::Size=Size(MF)) =
    similar_type(MArray, ElType, S)

Base.similar(mf::AbstractMultilinearForm, ElType::Type=eltype(mf), S::Size=Size(mf)) =
    similar_type(MArray, ElType, S)

Base.similar(mf::AbstractMultilinearForm, S::Size=Size(mf)) =
    similar_type(MArray, eltype(mf), S)

Base.similar(mf::AbstractMultilinearForm{K}, ::Type{T}, s::Dims) where {K,T} =
    Array{T,K}(undef, s)

Base.similar(mf::AbstractMultilinearForm{K}, s::Dims) where {K,T} =
    Array{eltype(mf), K}(undef, s)
#+end_src

Collect into a given container, (implicitly defaulting to a regular ~Array~ if no type argument is passed).
(/Actually, the above methods for ~similar_type~ may not be needed.  Excluding them for now./)

#+begin_src jupyter-julia :results silent
using StaticArrays: sacollect

# ARRGH! We be type pirates
# Also, this appears to have a small runtime cost, perhaps to compute `eltype(sized_gen)`
@inline function StaticArrays.sacollect(::Type{SA}, sized_gen) where {SA<:StaticArray}
    SA‚Ä≤ = similar_type(SA, eltype(sized_gen), Size(sized_gen))
    return sacollect(SA‚Ä≤, sized_gen)
end

@inline (::Type{SA})(mf::AbstractMultilinearForm) where {SA<:StaticArray} = sacollect(SA, mf)
#+end_src

Note that it would be nice if ~sacollect~ had a generic method that could handle iterators that possessed a ~Size~ trait without having to specify the size in the type ~SA~.  We have hacked that together above, but maybe something like this should be considered for inclusion in ~StaticArrays~ itself.

** Usage

Forming the identity matrix can be done as:
#+begin_src jupyter-julia
collect(inner)
#+end_src

But, since the size of each dimension is usually small, we integrate with ~StaticArrays~.
#+begin_src jupyter-julia :results silent
# Using sacollect
@assert sacollect(SArray, skew) == sacollect(MArray, skew)
# Using constructors
@assert SArray(skew) == MArray(skew)
#+end_src

** Collection routines

We can collect after contraction / "slicing", too.
#+begin_src jupyter-julia :results silent
@assert SArray(skew)[:,:,3,2] == SArray(skew(:,:, eÃÇ{3}(3), eÃÇ{3}(2)))
#+end_src

Let's make a functions dumping components into an arbitrary container.
#+begin_src jupyter-julia :eval no
function components!(tgt::AbstractArray, mf::MultilinearForm)
    same_size(mf, tgt)
    _unsafe_fill_components!(tgt, mf)
end

@generated function _unsafe_fill_components!(tgt::AbstractArray{<:Any,K}, mf::MultilinearForm{K}) where K
    # @inbounds this when ready to make this not safe
    quote
        @nloops $K i tgt begin
            (@nref $K tgt i) = (@nref $K mf i)
        end
        tgt
    end
end
#+end_src

#+begin_src jupyter-julia :eval no
@btime components!(A, mf) setup=begin
    mf = MultilinearForm{4,3}(_skew)
    A = MArray{NTuple{4,3}, eltype(mf)}(undef)
end;
#+end_src

** Known issues

For some reason, type aliases of ~SArray~ like ~SMatrix~ don't work.
#+begin_src jupyter-julia
SMatrix(inner)  # FIXME: this makes to do but is broken.
#+end_src

** Tests

#+begin_src jupyter-julia
let D = 3
    inner = MultilinearForm{2,D}(_inner)
    skew = MultilinearForm{4,D}(_skew)
    solo = MultilinearForm{0,D}(() -> 1.0)
    e = basis(StdUnitVector{D})
    @btime StaticArrays.sacollect(Scalar, $solo)
    @btime StaticArrays.sacollect(SMatrix{3,3}, $skew(:, $e[2], :, $e[3]))
end
#+end_src

#+begin_src jupyter-julia
let u = SVector{3}(1:3), v = SVector{3}(3:-1:1)
    @btime SArray(MultilinearForm{4,3}(_skew))
    out1 = @btime SArray(skew)[:,:,3,2]
    out2 = @btime SArray(skew(:,:, eÃÇ{3}(3), eÃÇ{3}(2)))
    @test out1 == out2
end
#+end_src


* More complex (and useful) multilinear forms

** Spherical harmonics

The functions below give the spherical harmonics (the traceless symmetric tensors) on \(\mathbb S^2\).
(/Note, these are great for unit tests!/ Can also check that the results are symmetric and traceless to ensure there is no regression in computing correct results.)

#+begin_src jupyter-julia
sphharm30(nÃÇ) = MultilinearForm{0,3}(() -> true)
sphharm31(nÃÇ) = MultilinearForm{1,3}((v) -> nÃÇ‚ãÖv)
sphharm32(nÃÇ) = MultilinearForm{2,3}((v1, v2) -> (nÃÇ‚ãÖv1)*(nÃÇ‚ãÖv2) - (v1‚ãÖv2)/3 )
sphharm33(nÃÇ) = MultilinearForm{3,3}((v1, v2, v3) ->
    (nÃÇ‚ãÖv1)*(nÃÇ‚ãÖv2)*(nÃÇ‚ãÖv3) - ((v1‚ãÖv2)*(nÃÇ‚ãÖv3) + (v3‚ãÖv1)*(nÃÇ‚ãÖv2) + (v2‚ãÖv3)*(nÃÇ‚ãÖv1))/5)
out = @btime SArray(sphharm33(x)) setup=(x=normalize(rand(SVector{3})))
# Check that the result is traceless, symmetric
# all(‚âà(tr(out[i,:,:]), 0, atol=eps(eltype(out))) for i ‚àà axes(out, 1))
#+end_src

#+RESULTS:
:RESULTS:
:   12.736 ns (0 allocations: 0 bytes)
#+begin_example
3√ó3√ó3 SArray{Tuple{3, 3, 3}, Float64, 3, 27} with indices SOneTo(3)√óSOneTo(3)√óSOneTo(3):
[:, :, 1] =
 -0.0104772  -0.126804    -0.154229
 -0.126804    0.00355026   0.00856803
 -0.154229    0.00856803   0.00692695

[:, :, 2] =
 -0.126804     0.00355026  0.00856803
  0.00355026  -0.124959    0.156944
  0.00856803   0.156944    0.251763

[:, :, 3] =
 -0.154229    0.00856803   0.00692695
  0.00856803  0.156944     0.251763
  0.00692695  0.251763    -0.00271477
#+end_example
:END:

These provide nice benchmarks
#+begin_src jupyter-julia
bmarks = let
    nÃÇ = rand(SVector{3})
    (u, v, w) = ntuple(_ -> round.(normalize(rand(SVector{3})), digits=2), Val(3))

    # fns = (sphharm32 => ((:, :), (:, v), (u, v)),
    #        sphharm33 => ((:, :, :), (:, :, w), (:, v, w), (u, v, w)))

    # b = Vector{BenchmarkTools.Trial}(undef, mapreduce(length ‚àò last, +, fns))

    # i = 0
    # for (fn, args_set) ‚àà fns
    #     println("Evaluating $fn at a random point on the sphere with")
    #     for (n, args) ‚àà enumerate(args_set)
    #         println("$fn(nÃÇ)$args")
    #         b[i+=1] = @benchmark $fn(nÃÇ)($args...) setup=(nÃÇ=normalize(rand(SVector{3, Float64})))
    #         println("  time = ", minimum(b[i].times))
    #     end
    # end

    println("Second order form")
    println("  all components -> 3x3 matrix")
    @btime SArray(sphharm32(nÃÇ[])) setup=(nÃÇ=$(Ref(nÃÇ)))
    println("  single contraction -> length-3 vector  (matrix-vector prodct)")
    @btime SArray(sphharm32(nÃÇ[])(:, v[])) setup=(nÃÇ=$(Ref(nÃÇ)); v=$(Ref(v)))
    println("  double contraction -> scalar  (quadratic form)")
    @btime sphharm32(nÃÇ[])(u[], v[]) setup=(nÃÇ=$(Ref(nÃÇ)); u=$(Ref(u)); v=$(Ref(v)))
    println()

    println("Thrid order form")
    println("  all components -> 3x3x3 array")
    @btime SArray(sphharm33(nÃÇ[])(:, :, :)) setup=(nÃÇ=$(Ref(nÃÇ));)
    println("  single contraction -> 3x3 matrix")
    @btime SArray(sphharm33(nÃÇ[])(:, :, u[])) setup=(nÃÇ=$(Ref(nÃÇ)); u=$(Ref(u)))
    println("  double contraction -> length-3 vector")
    @btime SArray(sphharm33(nÃÇ[])(:, u[], v[])) setup=(nÃÇ=$(Ref(nÃÇ)); u=$(Ref(u)); v=$(Ref(v)))
    println("  full contraction -> scalar")
    @btime sphharm33(nÃÇ[])(u[], v[], w[]) setup=(nÃÇ=$(Ref(nÃÇ)); u=$(Ref(u)); v=$(Ref(v)); w=$(Ref(w)))
end;
#+end_src

#+RESULTS:
#+begin_example
Second order form
  all components -> 3x3 matrix
  2.304 ns (0 allocations: 0 bytes)
  single contraction -> length-3 vector  (matrix-vector prodct)
  2.305 ns (0 allocations: 0 bytes)
  double contraction -> scalar  (quadratic form)
  3.282 ns (0 allocations: 0 bytes)

Thrid order form
  all components -> 3x3x3 array
  12.527 ns (0 allocations: 0 bytes)
  single contraction -> 3x3 matrix
  22.018 ns (0 allocations: 0 bytes)
  double contraction -> length-3 vector
  12.794 ns (0 allocations: 0 bytes)
  full contraction -> scalar
  5.238 ns (0 allocations: 0 bytes)
#+end_example

** Stokes-flow hydrodynamics

How about the almighty Stokeslet tensor \(S\) in three dimensions?  In the usual index notation,
\[ 8œÄ S_{ij}(\vec x) = \frac{Œ¥_{ij}}{r} + \frac{x_i x_j}{r^3}, \]
where \(\vec x\) is the position vector and \(r = |\vec x|\).
We can alternatively write the Stokeslet at each point as a multilinear function of two vectors,
\[ 8œÄ \left. S(\vec e, \vec f) \right|_{x} = \frac{Œ¥_{ij}}{r} + \frac{x_i x_j}{r^3}, \]
so \(S_{ij}(x) = \left. S(\hat{\vec e}_i, \hat{\vec e}_j) \right|_{x}\).

#+begin_src jupyter-julia
function stokeslet(x)
    # For efficiency, pre-compute quantities depending on position (x) alone.
    # We also reduce division as much as possible in favor multiplication
    # (faster).
    recip_r = inv(norm(x))
    xÃÇ = x * recip_r
    prefactor = recip_r / 8œÄ

    # Here is the "implementation" function
    impl(e, f) = ((e‚ãÖf) + (e‚ãÖxÃÇ)*(xÃÇ‚ãÖf)) * prefactor
    # (Compare to the usual index notation.)

    # Now make it a second order multilinear form in three dimensions
    return MultilinearForm{2,3}(impl)
end
@btime SArray(stokeslet(x)) setup=(x=SVector{3,Float64}(1.,2,3))
#+end_src

#+RESULTS:
:RESULTS:
:   7.970 ns (0 allocations: 0 bytes)
: 3√ó3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)√óSOneTo(3):
:  0.0113936   0.00151914  0.00227871
:  0.00151914  0.0136723   0.00455742
:  0.00227871  0.00455742  0.0174701
:END:

We are left with a matrix of the components of our favorite (symmetric) tensor.
We can also contract the Stokeslet with a (force) vector to give the Stokeslet velocity field at a given point.
#+begin_src jupyter-julia
@btime SArray(stokeslet(x)(:,f)) setup=begin
    x = SVector{3,Float64}(1,2,3) # Position vector
    f = SVector{3,Float64}(3,2,1) # Force vector
end
#+end_src

If we use a ~StdUnitVector~ as one of the vectors, we should get the corresponding column/row of the Stokeslet as a matrix.
#+begin_src jupyter-julia
@btime SArray(stokeslet(x)(:,f)) setup=begin
    x = SVector{3,Float64}(1,2,3)
    f = eÃÇ{3}(2)
end
#+end_src

Computational cost is reduced if you contract the Stokeslet with a vector because the "full" matrix is never formed.
Contraction with a unit vector is even cheaper, since it is equivalent to forming just one row of the Stokeslet.
We can even compute just a single component of the velocity as a scalar.
#+begin_src jupyter-julia
@btime stokeslet(x)(e,f) setup=begin
    x = SVector{3,Float64}(1,2,3)
    # Direction of flow diagonally on xy plane
    e = normalize(SVector{3,Float64}(1,1,0))
    f = SVector{3,Float64}(3,2,1)
end
#+end_src

#+RESULTS:
:RESULTS:
:   5.657 ns (0 allocations: 0 bytes)
: 0.053709744814769436
:END:

As it is possible to pick out a row/column, it is also possible to pick out just one component of the Stokeslet by feeding it two ~StdUnitVector~‚Äãs.
#+begin_src jupyter-julia
@btime stokeslet(x)(e,f) setup=begin
    x = SVector{3,Float64}(1,2,3)
    e = eÃÇ{3}(1)
    f = eÃÇ{3}(2)
end
#+end_src

#+RESULTS:
:RESULTS:
:   4.330 ns (0 allocations: 0 bytes)
: 0.0015191409909728994
:END:

Note that, in all cases, most of the computational cost of evaluating a Stokeslet is actually due to computation of the spatial dependence (taking ~norm(x)~, etc.), though this can be somewhat reduced by annotating the definition of ~stokeslet~ with ~@fastmath~.
#+begin_src jupyter-julia
@btime stokeslet(x) setup=(x = SVector{3}(1., 2., 3.));
#+end_src

Without all this machinery, the Stokeslet is not too hard to express using matrix multiplication and ~LinearAlgebra.I~
#+begin_src jupyter-julia
function stokeslet2(x)
    recip_r = inv(norm(x))
    xÃÇ = x * recip_r
    prefactor = recip_r / 8œÄ
    (SMatrix{3,3,Float64}(I) .+ xÃÇ .* xÃÇ') .* prefactor
end
@btime stokeslet2(SVector(1.,2,3))
#+end_src

Somehow, our code is actually a hair faster!
However, the real advantage is mental workload.
To get the matrix-vector product to get the fluid velocity, you can either do the inefficient method of calling the function above and then calling ~dot~, or writing a whole separate function to do things the algorithmically more efficient way.
#+begin_src jupyter-julia
function stokeslet_dot_f(x, f)
    recip_r = inv(norm(x))
    xÃÇ = x * recip_r
    prefactor = recip_r / 8œÄ
    (f .+ xÃÇ.*(xÃÇ‚ãÖf)) .* prefactor
end
let f = normalize(rand(SVector{3}))
    x = rand(SVector{3})
    @btime stokeslet2($x) * $f  # Less efficient
    @btime stokeslet_dot_f($x, $f)
end
#+end_src

If we include third order tensors (e.g. stresslets), the ergonomic advantages of ~MultilinearForms~ are significantly more apparent.

Stokeslets at many points:
#+begin_src jupyter-julia
function fmap!(f::F, buf, argss...) where F
    @assert eltype(buf) === similar_type(f(map(first, argss)...))
    for (i, args) ‚àà enumerate(zip(argss...))
        buf[i] = f(args...)
    end
    buf
end

function fmap(f::F, argss...) where F
    ElT = typeof(f(map(first, argss)...))
    buf = similar(first(argss), ElT)
    fmap!(f, buf, argss...)
end

let n = 10000
    xs = rand(SVector{3,Float64}, n)
    xs_grid = (SVector{3,Float64}(x,y,0) for x in LinRange(-1, 1, 100), y in LinRange(-1, 1, 100))
    fs = rand(SVector{3,Float64}, n)

    ElT_mat = similar_type(stokeslet(first(xs)))
    ElT_vec = similar_type(stokeslet(first(xs))(:, first(fs)))
    buf_mat = Vector{ElT_mat}(undef, n)
    buf_vec = Vector{ElT_vec}(undef, n)
    # buf = @btime Vector{$ElT}(undef, $n)  # alloc time is ~500-600ns

    # Inlining is important here!
    @inline fun(x) = SArray(stokeslet(x))
    @inline fun(x,f) = SArray(stokeslet(x)(:,f))

    @btime SArray(stokeslet(first($xs)))                 # one evaluation
    @btime map($fun, $xs)                               # many evalutations
    @btime SArray(stokeslet(first($xs))(:, first($fs)))  # one evaluation
    @btime map($fun, $xs, $fs)                          # many evalutations
    # Using map or a comprehension is slow... or doesn't inlne
end
#+end_src

#+RESULTS:
:RESULTS:
:   7.690 ns (0 allocations: 0 bytes)
:   84.927 Œºs (2 allocations: 703.17 KiB)
:   6.572 ns (0 allocations: 0 bytes)
:   81.504 Œºs (2 allocations: 234.42 KiB)
#+begin_example
10000-element Vector{SVector{3, Float64}}:
 [0.04715144925397651, 0.047250688983778044, 0.057360169194439044]
 [0.05634273142907477, 0.028546360812883313, 0.04200599301925375]
 [0.05998095512430601, 0.09429276853041374, 0.09183203033568504]
 [0.10618539785661343, 0.014160641577274487, 0.058298259987683856]
 [0.03577010362658258, 0.047267196304746226, 0.04844484569608786]
 [0.029337082922906155, 0.03344132644097695, 0.051566341144922485]
 [0.029818617097478333, 0.02346081234438996, 0.014398057032036447]
 [0.044045671824790696, 0.009198059734425982, 0.037058559699495]
 [0.04292147289879901, 0.042228236989801084, 0.01428071427326212]
 [0.038282643103885274, 0.04371780385832892, 0.03836431597393986]
 [0.05659224498399519, 0.037635578443029144, 0.05775761203888972]
 [0.09244262285602918, 0.13378099973344645, 0.12945892555291907]
 [0.04501968445812788, 0.049018879558305514, 0.05609768088110643]
 ‚ãÆ
 [0.018509347725539367, 0.04859762235731808, 0.07324649264761544]
 [0.009869179219133639, 0.02317395688177446, 0.046608596598066605]
 [0.039119396715329734, 0.0254908347430429, 0.03568646130354116]
 [0.017989157968789225, 0.01240562849738882, 0.02022420336615706]
 [0.03646108516608767, 0.04001256531104855, 0.017649425158601288]
 [0.012119504323520972, 0.016585845469078774, 0.02841307823346314]
 [0.006521843467137135, 0.028248901972918, 0.01854282905034674]
 [0.08646504185722842, 0.05430554055221529, 0.07380143935452227]
 [0.022783816834751527, 0.04438304564452026, 0.053548301202900675]
 [0.06430025660576616, 0.04504645934667494, 0.0553691223478648]
 [0.03617340441255815, 0.01775170268985513, 0.038442848843676325]
 [0.06324679658241876, 0.04935062654516673, 0.04618419992302575]
#+end_example
:END:


Plot the Stokeslet, for fun.
#+begin_src jupyter-julia
using CairoMakie

let x‚Éós = (SVector(x, y, 0.) for x ‚àà LinRange(-3, 3, 201), y ‚àà LinRange(-3, 3, 201))
    f‚Éó = StdUnitVector{3}(1)  # = ùêûÃÇ‚Çì
    x‚Éó = first(x‚Éós)
    # @btime SArray(stokeslet($(Ref(x‚Éó))[])(:, $(Ref(f‚Éó))[]))
    # @btime map(x‚Éó -> SArray(stokeslet(x‚Éó)(:, $f‚Éó)), $x‚Éós)

    # Makie needs a function in a rather speficic format.
    stokeslet_plotfn(x‚Éó::Point2) = Point2f(SArray(stokeslet(SVector(x‚Éó..., 0.))(:,f‚Éó))[SOneTo(2)])
    streamplot(stokeslet_plotfn, -3..3, -2..2, axis=(;aspect=DataAspect()))
end
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/6adf2ec88750168a5ae1b839b670e00ee24ed08f.png]]

** Known issues

*** Collection to a ~StaticArrays.Scalar~ is broken.

#+begin_src jupyter-julia
@btime SArray(stokeslet(x)(e,f)) setup=begin
    x = SVector{3,Float64}(1,2,3)
    e = SVector{3,Float64}(1,1,1)
    f = SVector{3,Float64}(3,2,1)
end
#+end_src
