#+OPTIONS: toc:nil
#+PROPERTY: header-args:jupyter-julia :session DevNotes :kernel julia :eval no-export :async yes :exports both

:TEX_MATHJAX_SETUP:
#+LATEX_COMPILER: lualatex

# #+LATEX_HEADER: \usepackage[margin=48bp,paperwidth=7in,paperheight=10in]{geometry}
#+LATEX_HEADER: \AtBeginDocument{\renewcommand*{\vec}{\symbf}}
#+LATEX_HEADER: \AtBeginDocument{\newcommand*{\uvec}[1]{\hat{\vec #1}}}
#+LATEX_HEADER: \newcommand*{\norm}[1]{|#1|}
#+LATEX_HEADER: \newcommand*{\ten}{\symbfsf}
#+LATEX_HEADER: \newcommand*{\pd}{\partial}
#+LATEX_HEADER: \newcommand*{\grad}{\vec\nabla}
#+LATEX_HEADER: \newcommand*\dd{\mathop{}\!\mathrm{d}}
#+LATEX_HEADER: \newcommand*\Reals{\symbb R}
#+LATEX_HEADER: \DeclareMathOperator{\supp}{supp}

#+LATEX_HEADER: \setmainfont{STIX Two Text}
#+LATEX_HEADER: \setmathfont{STIX Two Math}
#+LATEX_HEADER: \setmonofont{JuliaMono}

#+LATEX_HEADER: \setlength{\parindent}{0pt}
#+LATEX_HEADER: \setlength{\parskip}{\medskipamount}

# Macros for MathJAX
#+begin_export html
\(
\newcommand{\pd}{\partial}
\renewcommand{\vec}{\boldsymbol}
\newcommand{\uvec}[1]{\hat{\vec #1}}
\renewcommand{\ten}[1]{\boldsymbol{\mathsf{#1}}}
\newcommand\dd{\mathop{}\!\mathrm{d}}
\newcommand{\grad}{\vec\nabla}
\newcommand{\symbb}{\mathbb}
\newcommand{\Reals}{\symbb R}
\newcommand\NRe{\mathinner{Re}}
\newcommand{\norm}[1]{|#1|}
\DeclareMathOperator{\supp}{supp}
\)
#+end_export
:END:

:JULIA_SETUP:
#+begin_src jupyter-julia :results silent :exports none
using MultilinearForms

showit(x) = (show(stdout, "text/plain", x); println())
#+end_src

:END:


#+TITLE: Multilinear Forms: Implementation Notes


* Introduction

[[https://en.wikipedia.org/wiki/Multilinear_form][Multilinear forms]] map \(K\) \(D\)-dimensional vectors to a scalar quantity.
An important example of a multilinear form is the standard inner product (dot product) of vectors, which is a bilinear form (also called a 2-linear form or a 2nd order multilinear form).
#+begin_src jupyter-julia :results silent
using LinearAlgebra
@inline _inner(v1, v2) = v1 ⋅ v2
@inline _inner(vs::NTuple{2}) = _inner(vs...)
#+end_src
It takes two vectors and produces a scalar.
A \(K\)th order multilinear form \(f\) can be represented in terms of scalar components \(A_{i_1 ⋯ i_K}\) as
\begin{equation*}
f(v_1, ⋯, v_K) = A_{i_1 ⋯ i_K} v_{1 i_1} ⋯ v_{K i_K}
\end{equation*}
and therefore are often encoded as multidimensional arrays.
The components can be extracted by setting each of the vectors \(\vec v_k\) to each of the unit vectors \(\uvec e_j\)
For example, if the vectors are all unit vectors, \(I(\uvec e_i, \uvec e_j) = \uvec e_i ⋅ \uvec e_2 \), correspond to the Kronecker delta \(δ_{ij}\).
However, representing multilinear forms as functions on vectors is also useful and can be more computationally efficient, especially if the tensor \(A\) is not of full rank or can be represented in a particular form.
(For instance, computing an inner product by naively multiplying by the identity matrix by \(v_1\) on the left and \(v_2\) on the right is not very efficient.)
Like general tensors, multilinear forms are invariant under a change of coordinates.

Here is another example of a 4-linear form, which takes four vectors and produces a scalar
#+begin_src jupyter-julia :results silent
@inline _skew(v1, v2, v3, v4) = ((v1⋅v3)*(v2⋅v4) - (v1⋅v4)*(v2⋅v3))
@inline _skew(vs::NTuple{4}) = _skew(vs...)
#+end_src
and has components \(δ_{ik} δ_{jl} - δ_{il} δ_{jk}\).

** Functions on indices

The following functions are similar to ~_inner~ and ~_skew~, but are directly functions of indices rather than vectors.  They are essentially equivalent if one restricts attention to ~v1, ⋯, vN~ being one of the standard unit vectors \(\uvec e_1 ⋯ \uvec e_N\).
We can use them to directly compute the components of each form in a way that is efficient over taking dot products of (over the product space of) the standard unit vectors in \(\Reals^D\).
#+begin_src jupyter-julia :results silent
# The Kronecker delta, δ_{ij}, as a function of indices
inner_ixfn(i, j) = (i==j)
@inline inner_ixfn(args::Dims{2}) = inner_ixfn(args...)
@inline inner_ixfn(I::CartesianIndex{2}) = inner_ixfn(Tuple(I)...)

# A 4th order isotropic tensor, δ_{ik} δ_{jl} - δ_{il} δ_{jk}
skew_ixfn(i, j, k, l) = (i==k) * (j==l) - (i==l) * (j==k)
@inline skew_ixfn(args::Dims{4}) = skew_ixfn(args...)
@inline skew_ixfn(I::CartesianIndex{4}) = skew_ixfn(Tuple(I)...)
#+end_src

We can loop over functions like these to fill up an array of tensor components, as demonstrated by the following functions.
#+begin_src jupyter-julia :results silent
using Base.Cartesian

"""
Fill `arr` with function `f` using CartesianIndices()
"""
function fillfn_cartesianindices!(arr, f::F) where F  # force specialization
    for I ∈ CartesianIndices(arr)
        @inbounds arr[I] = f(I)
    end
    return arr
end

@generated function fillfn_basecartesian!(arr::AbstractArray{<:Any,N}, f::F) where {N,F}
    quote
        @nloops $N i arr begin
            @inbounds (@nref $N arr i) = (@ncall $N f i)
        end
        arr
    end
end

const fillfn! = fillfn_basecartesian!
#+end_src

The first form is more elegant and idiomatic Julia code, but the second, which generates a function with explicit nested loops, is for some reason much more performant when the input array to be filled is a ~StaticArray~.
Here, we demonstrate for ~_skew~, which represents a fourth order isotropic tensor.

#+begin_src jupyter-julia
using BenchmarkTools
using StaticArrays
using StaticArrays: sacollect

let # SDims = NTuple{4,3}
    # dims = fieldtypes(SDims)
    # ixfn = skew_ixfn
    # T = eltype(ixfn(ntuple(_ -> 1, Val(fieldcount(SDims)))))

    println("  Iteration over `CartesianIndices`")
    out1 = @btime(
        fillfn_cartesianindices!(A, $skew_ixfn),
        setup=(A = MArray{NTuple{4,3},Int}(undef))
    )
    println("  Using `Base.Cartesian`")
    out2 = @btime(
        fillfn_basecartesian!(A, $skew_ixfn),
        setup=(A = MArray{NTuple{4,3},Int}(undef))
    )

    println("`SArray` via `sacollect`")
    out3 = @btime(
        sacollect(SArray{NTuple{4,3}}, $skew_ixfn(I) for I ∈ Is),
        setup=(Is = CartesianIndices(ntuple(_ -> SOneTo(3), Val(4))))
    )

    @assert out1 == out2 == out3
    out3
end
#+end_src

~sacollect~ is most efficient because it effectively unrolls all the loops.
However, using approaches with looping might be beneficial in cases where loop unrolling would create too much work for the compiler.
We will try to sacrifice as little performance over these "baseline" functions on indices as possible in our implementation below.


* Unit vectors and indices

There is really no distinction between functions on indices, which give the components of a tensor, and multilinear forms on the standard unit vectors because the index \(i\) directly maps over to the unit vector \(e_i\) pointing in the \(i\)th direction.
We therefore define a special type to represent such standard unit vectors (see [[file:src/stdbasis.jl][stdbasis.jl]]).

Important points about the implementation:
- the dot product of two ~StdUnitVector~​s amounts to checking if they point in the same direction
- the dot product of a ~StdUnitVector~ with a "regular" vector just performs indexing
- the dot product of any other kinds of "regular" vectors just falls back to the usual algorithm given by ~LinearAlgebra.dot~

Now, if we evaluate ~_inner~ where the all arguments are ~StdUnitVector{N}~​s (unit vectors in \(\mathbb R^N\)), we really just have a function that tests whether the ~direction~ of each vector is the same.
For example, the dot product between two unit vectors, ~[1, 0, 0]~ and ~[0, 0, 1]~, is reduced to testing whether ~1==3~, which evaluates to ~false == 0~.

Below, we use an array comprehension to loop over the unit vectors to produce the \(3×3\) identity matrix.
#+begin_src jupyter-julia
let e = basis(StdUnitVector{3})
    [_inner(e[i], e[j]) for j ∈ eachindex(e), i ∈ eachindex(e)]
end
#+end_src

** Tests

#+begin_src jupyter-julia
using Test

@testset "Unit Vectors" begin
    # Construction
    @test StdUnitVector{2}(1) isa StaticVector{2,Bool}
    @test length(StdUnitVector{2}(1)) == only(size(StdUnitVector{2}(1)))
    @test_throws DomainError StdUnitVector{2}(3)
    @test_throws DomainError StdUnitVector{1}(0)
    @test only(StdUnitVector{1}(1))
    # Equality testing
    @test StdUnitVector{2}(1) == StdUnitVector{2}(1)
    @test StdUnitVector{2}(1) !== StdUnitVector{2}(2)
    @test StdUnitVector{2}(1) !== StdUnitVector{3}(1)
    @test StdUnitVector{2}(1) == Bool[true, false]
    @test StdUnitVector{2}(1) !== Bool[true, false, false]
    # Dot product
    @test @inferred StdUnitVector{1}(1) ⋅ StdUnitVector{1}(1)
    @test StdUnitVector{2}(1) ⋅ StdUnitVector{2}(1)
    @test !(StdUnitVector{2}(1) ⋅ StdUnitVector{2}(2))
    @test !(StdUnitVector{2}(2) ⋅ StdUnitVector{2}(1))
    @test StdUnitVector{2}(1) ⋅ [1,2] == [1,2] ⋅ StdUnitVector{2}(1) == 1
    @test StdUnitVector{2}(2) ⋅ [1,2] == [1,2] ⋅ StdUnitVector{2}(2) == 2
    @test StdUnitVector{2}(1) ⋅ SVector(1,2) == SVector(1,2) ⋅ StdUnitVector{2}(1) == 1
    @test StdUnitVector{2}(2) ⋅ [1,2] == [1,2] ⋅ StdUnitVector{2}(2) == 2
    @test_throws DimensionMismatch StdUnitVector{2}(1) ⋅ StdUnitVector{1}(1)
    @test_throws DimensionMismatch SVector(1,2) ⋅ StdUnitVector{1}(1)
    @test_throws DimensionMismatch [1,2] ⋅ StdUnitVector{1}(1)
    # Other
    @test StdUnitVector{2}(1) + StdUnitVector{2}(2) === ones(SVector{2,eltype(true+true)})
    @test @inferred(StdUnitVector{2}(2) + [1,0]) == ones(2)
end;
#+end_src

** Performance

We can check for any overhead compared to direct computation on the indices, and there seems to be none.
#+begin_src jupyter-julia :results scalar
using MultilinearForms: Safety, SAFE, UNSAFE

@inline inds2uvecs(safety::S, inds::Vararg{Int}) where {S<:Safety} = map(i -> StdUnitVector{3}(safety, i), inds)
@inline inds2uvecs(safety::S) where {S<:Safety} = (inds...) -> inds2uvecs(safety, inds...)
# @inline inds2uvecs(I::CartesianIndex) = map(StdUnitVector{3}, Tuple(I))
out1 = @btime fillfn_basecartesian!(A, skew_ixfn) setup=(A = MArray{NTuple{4,3},Int64}(undef))
out2 = @btime(fillfn_basecartesian!(A, _skew ∘ inds2uvecs(UNSAFE)),
              setup=(A = MArray{NTuple{4,3},Int64}(undef)))
@assert out1 == out2
#+end_src

Interestingly, completely explicit loops are little faster, but why?

#+begin_src jupyter-julia
@btime(
    begin for l ∈ axes(A,4), k ∈ axes(A,3), j ∈ axes(A,2), i ∈ axes(A,1)
        @inbounds A[i,j,k,l] = _skew(StdUnitVector{3}(UNSAFE, i), StdUnitVector{3}(UNSAFE, j),
                                     StdUnitVector{3}(UNSAFE, k), StdUnitVector{3}(UNSAFE, l))
    end
    A
    end,
    setup=(A = MArray{NTuple{4,3}, Int64}(undef))
);
#+end_src


* Multilinear forms

In [[file:src/MultilinearForms.jl][MultilinearForms.jl]], we define a callable type ~MultilinearForm~ whose instances represent multilinear forms.
A ~MultilinearForm~ is constructed by passing an "implementation" function like ~_inner~ or ~_skew~.
We'll restrict our attention to the case where the vectors operated on by a given ~MultilinearForm~ are of known spatial dimension (~length~), usually being between 1--4 and most commonly 2 or 3.
Thus, we represent such vectors using types from ~StaticArrays~ for efficiency.

Check that things work efficiently (no allocations, e.g.).

#+begin_src jupyter-julia :results scalar
using BenchmarkTools
using Test

let u = SVector(1, 0, 0), v = SVector{3}(0, 1, 0)
    inner = MultilinearForm{2,3}(_inner)
    skew = MultilinearForm{4,3}(_skew)
    println("Contraction, form of order $(order(inner)) in $(dimension(inner)) dimensions")
    @assert 1 == @btime($inner($(u,u)))
    println("Contraction, form of order $(order(skew)) in $(dimension(skew)) dimensions")
    @assert 1 == @btime($skew($(u,v,u,v)))
end
#+end_src

We can think of a ~MultilinearForm~ applied to only ~N~ of its ~K~ arguments as a similar multilinear form of order ~K-N~.
We call such a multilinear form "contracted", which is implemented by ~ContractedMultilinearForm~.
We also use the ~Colon~ (~:~) to indicate a "free index" of the tensor / form.
When a ~MultilinearForm~ is ~collect~​ed into an array, the ~:~ indicates slots/indices which should be looped over for all the unit vectors to generate numerical components.

We might want more functionality in the future, like the ability to permute the argument order of the vector arguments.
We leave that to later work.

Let's define a few ~MultilinearForms~ (in three dimensions) to work on below.
#+begin_src jupyter-julia :results silent
const ê = StdUnitVector
_just_true() = true
const solo = MultilinearForm{0,3}(_just_true)
const inner = MultilinearForm{2,3}(_inner)
const skew = MultilinearForm{4,3}(_skew)
#+end_src

** Tests

#+begin_src jupyter-julia
using Test

@testset "Multilinear Form -> Scalar" begin
    u = StdUnitVector{2}(1) # SVector(1., 0.)
    v = StdUnitVector{2}(2) # SVector(0., 1.)
    solo = @inferred MultilinearForm{0,3}(_just_true)
    inner = @inferred MultilinearForm{2,2}(_inner)
    skew = @inferred MultilinearForm{4,2}(_skew)
    @test inner(u,u) == 1
    @test inner(u,v) == 0
    @test inner(v,u) == 0
    @test skew(u,u,v,v) == 0
    @test skew(u,v,u,v) == 1
    @test skew(u,v,v,u) == -1
end
@testset "Multilinear Form -> Contracted Form" begin
    let
        u = StdUnitVector{2}(1) # SVector(1., 0.)
        v = StdUnitVector{2}(2) # SVector(0., 1.)
        inner = @inferred MultilinearForm{2,2}(_inner)
        @test_throws MethodError inner(:,:,:)
        @test_throws MethodError inner(:)
        @test inner(:,:) === inner
        @inferred inner(u,:)
        @test 1 == inner(u,u) == @inferred inner(u,:)(u) == @inferred inner(:,u)(u)
    end
    let (u,v,w,x) = ntuple(_ -> rand(SVector{3,Float64}), Val(4))
        inner = @inferred MultilinearForm{2,3}(_inner)
        skew = @inferred MultilinearForm{4,3}(_skew)
        @inferred skew(u,v,w,:)
        @inferred skew(u,v,w,:)(x)
        @test inner(u,v) == inner(u,:)(v) == inner(:,u)(v) == inner(:,:)(u,v)
        @test skew(u,v,w,x) ≈ skew(u,v,w,:)(x) ≈ skew(u,v,:,:)(w,x) ≈
            skew(u,:,:,:)(v,w,x) ≈ skew(:,v,w,x)(u)
    end
end;
#+end_src

* Interfaces for iteration, indexing, etc.

If we evaluate ~inner~ where the arguments are all unit vectors, we find that we have a lazy representation of the identity tensor, since \(\uvec e_i ⋅ \uvec e_j = δ_{ij}\) is equivalent to the Kronecker delta (one if \(i=j\) and zero otherwise).
Below, we use an array comprehension to loop over the unit vectors to produce the identity matrix.
#+begin_src jupyter-julia
let e = basis(StdUnitVector{3})
    inner = MultilinearForm{2,3}(_inner)
    [inner(e[i], e[j]) for j ∈ eachindex(e), i ∈ eachindex(e)]
end
#+end_src

Note that a matrix of ~true~ or ~false~ boolean values is created due to our implementation of ~StdUnitVector~, which is analogous to how ~LinearAlgebra.I~ works.
This will help types be promoted as expected for different vector arguments.

Some convenience is provided by implementing the [[https://docs.julialang.org/en/v1/manual/interfaces/][iteration and indexing interfaces]] for ~MultilinearForm~​s.
This will allow us to "collect" a ~MultilinearForm~ into an array container like ~Array~ or ~SArray~ using ~collect~ or ~StaticArrays.sacollect~, respectively.
(Note that we commit some type piracy in doing so.  It would be nice if ~sacollect~ had a generic method that could handle iterators that possessed a ~Size~ trait without having to specify the size in the type ~SA~.  We have hacked that together above, but maybe something like this should be considered for inclusion in ~StaticArrays~ itself.)
Indexing is done by simply converting each index to a corresponding ~StdUnitVector~ like ~mf[i,j,...] = mf(StdUnitVector{3}(i), StdUnitVector{3}(j), ...)~, to provide a convenience shorthand.
The methods necessary to make this work are implemented in [[file:src/MultilinearForms.jl][MultilinearForms.jl]].
There, we also implement methods for ~StaticArrays.similar_type~ and ~Base.similar~ to provide appropriate types to contain components of ~MultilinearForms~.

** Collection

The identity matrix (~inner~) can now be collected into an array with a single line of code.
#+begin_src jupyter-julia
collect(inner)
#+end_src

But, since the size of each dimension is usually small and a fixed constant, we integrate with ~StaticArrays~.
#+begin_src jupyter-julia
let
    sacollect(SArray, inner) |> showit
    sacollect(MArray, inner) |> showit
end;
#+end_src

We can collect after contraction / "slicing", too.
Let's get a slice or two of the ~skew~ tensor 🍕.
#+begin_src jupyter-julia
let skew_components = SArray(skew)  # Materialize the whole tensor
    # Now, slice the component array and compare it to tensor contraction
    # with the unit vectors
    @assert SArray(skew(ê{3}(1), :, ê{3}(2), :)) == skew_components[1,:,2,:]
    @assert SArray(skew(:, :, ê{3}(3), ê{3}(2))) == skew_components[:,:,3,2]
    SArray(skew(ê{3}(1), :, ê{3}(2), :)) |> showit
    SArray(skew(:, :, ê{3}(3), ê{3}(2))) |> showit
end;
#+end_src

Note that components of the tensor the user has not asked for are never computed.

*** Maybe use this? :noexport:
Let's make a functions dumping components into an arbitrary container.
#+begin_src jupyter-julia :eval no
function components!(tgt::AbstractArray, mf::MultilinearForm)
    same_size(mf, tgt)
    _unsafe_fill_components!(tgt, mf)
end

@generated function _unsafe_fill_components!(tgt::AbstractArray{<:Any,K}, mf::MultilinearForm{K}) where K
    # @inbounds this when ready to make this not safe
    quote
        @nloops $K i tgt begin
            (@nref $K tgt i) = (@nref $K mf i)
        end
        tgt
    end
end
#+end_src

#+begin_src jupyter-julia :eval no
@btime components!(A, mf) setup=begin
    mf = MultilinearForm{4,3}(_skew)
    A = MArray{NTuple{4,3}, eltype(mf)}(undef)
end;
#+end_src

** Known issues

For some reason, type aliases of ~SArray~ like ~SMatrix~ don't work.
#+begin_src jupyter-julia
SMatrix(inner)  # FIXME: this makes to do but is broken.
#+end_src

** Validity & Performance Checks

#+begin_src jupyter-julia
let D = 3
    inner = MultilinearForm{2,D}(_inner)
    skew = MultilinearForm{4,D}(_skew)
    solo = MultilinearForm{0,D}(() -> 1.0)
    e = basis(StdUnitVector{D})
    @btime StaticArrays.sacollect(Scalar, $solo)
    @btime StaticArrays.sacollect(SMatrix{3,3}, $skew(:, $e[2], :, $e[3]))
end
#+end_src

#+begin_src jupyter-julia
let u = SVector{3}(1:3), v = SVector{3}(3:-1:1)
    @btime SArray(MultilinearForm{4,3}(_skew))
    out1 = @btime SArray(skew)[:,:,3,2]
    out2 = @btime SArray(skew(:,:, ê{3}(3), ê{3}(2)))
    @test out1 == out2
end
#+end_src


* More complex (and useful) multilinear forms

** Spherical harmonics

The functions below give the spherical harmonics (the traceless symmetric tensors) on \(\mathbb S^2\).
(/Note, these are great for unit tests!/ Can also check that the results are symmetric and traceless to ensure there is no regression in computing correct results.)

#+begin_src jupyter-julia
sphharm30(n̂) = MultilinearForm{0,3}(() -> true)
sphharm31(n̂) = MultilinearForm{1,3}((v) -> n̂⋅v)
sphharm32(n̂) = MultilinearForm{2,3}((v1, v2) -> (n̂⋅v1)*(n̂⋅v2) - (v1⋅v2)/3 )
sphharm33(n̂) = MultilinearForm{3,3}((v1, v2, v3) ->
    (n̂⋅v1)*(n̂⋅v2)*(n̂⋅v3) - ((v1⋅v2)*(n̂⋅v3) + (v3⋅v1)*(n̂⋅v2) + (v2⋅v3)*(n̂⋅v1))/5)
out = @btime SArray(sphharm33(x)) setup=(x=normalize(rand(SVector{3})))
# Check that the result is traceless, symmetric
# all(≈(tr(out[i,:,:]), 0, atol=eps(eltype(out))) for i ∈ axes(out, 1))
#+end_src

Lets check the performance of these functions.
#+begin_src jupyter-julia
bmarks = let
    n̂ = rand(SVector{3})
    (u, v, w) = ntuple(_ -> round.(normalize(rand(SVector{3})), digits=2), Val(3))

    # fns = (sphharm32 => ((:, :), (:, v), (u, v)),
    #        sphharm33 => ((:, :, :), (:, :, w), (:, v, w), (u, v, w)))

    # b = Vector{BenchmarkTools.Trial}(undef, mapreduce(length ∘ last, +, fns))

    # i = 0
    # for (fn, args_set) ∈ fns
    #     println("Evaluating $fn at a random point on the sphere with")
    #     for (n, args) ∈ enumerate(args_set)
    #         println("$fn(n̂)$args")
    #         b[i+=1] = @benchmark $fn(n̂)($args...) setup=(n̂=normalize(rand(SVector{3, Float64})))
    #         println("  time = ", minimum(b[i].times))
    #     end
    # end

    println("Second order form")
    println("  all components -> 3x3 matrix")
    @btime SArray(sphharm32(n̂[])) setup=(n̂=$(Ref(n̂)))
    println("  single contraction -> length-3 vector  (matrix-vector prodct)")
    @btime SArray(sphharm32(n̂[])(:, v[])) setup=(n̂=$(Ref(n̂)); v=$(Ref(v)))
    println("  double contraction -> scalar  (quadratic form)")
    @btime sphharm32(n̂[])(u[], v[]) setup=(n̂=$(Ref(n̂)); u=$(Ref(u)); v=$(Ref(v)))
    println()

    println("Thrid order form")
    println("  all components -> 3x3x3 array")
    @btime SArray(sphharm33(n̂[])(:, :, :)) setup=(n̂=$(Ref(n̂));)
    println("  single contraction -> 3x3 matrix")
    @btime SArray(sphharm33(n̂[])(:, :, u[])) setup=(n̂=$(Ref(n̂)); u=$(Ref(u)))
    println("  double contraction -> length-3 vector")
    @btime SArray(sphharm33(n̂[])(:, u[], v[])) setup=(n̂=$(Ref(n̂)); u=$(Ref(u)); v=$(Ref(v)))
    println("  full contraction -> scalar")
    @btime sphharm33(n̂[])(u[], v[], w[]) setup=(n̂=$(Ref(n̂)); u=$(Ref(u)); v=$(Ref(v)); w=$(Ref(w)))
end;
#+end_src

It seems to be as good as we can expect.
Significantly better than in other technical computing environments.

** Stokes-flow hydrodynamics

How about the all-important (to me) Stokeslet tensor \(S\) in three dimensions?  In the usual index notation,
\[ 8π S_{ij}(\vec x) = \frac{δ_{ij}}{r} + \frac{x_i x_j }{r^3}, \]
where \(\vec x\) is the position vector and \(r = |\vec x|\).
We can also write the Stokeslet at each point as a multilinear function
\[ 8π \left. S(\uvec e, \vec f) \right|_{x} = \frac{\uvec e ⋅ \vec f}{r} + \frac{(\uvec e ⋅ \vec x)(\vec f ⋅ \vec x)}{r^3}, \]
where \(\uvec e\) is a unit vector (in an arbirary direction) representing the direction of the flow speed that is computed and \(f\) is the point force at the origin.

Thus, we can get the \(ij\)-th component as \(S_{ij}(x) = \left. S(\hat{\vec e}_i, \hat{\vec e}_j) \right|_{x}\).

#+begin_src jupyter-julia
function stokeslet(x)
    # For efficiency, pre-compute quantities depending on position (x) alone.
    # We also reduce division as much as possible in favor multiplication
    # (faster).
    recip_r = inv(norm(x))
    x̂ = x * recip_r
    prefactor = recip_r / 8π

    # Here is the "implementation" function
    impl(e, f) = ((e⋅f) + (e⋅x̂)*(x̂⋅f)) * prefactor
    # (Compare to the usual index notation.)

    # Now make it a second order multilinear form in three dimensions
    return MultilinearForm{2,3}(impl)
end
@btime SArray(stokeslet(x)) setup=(x=SVector{3,Float64}(1.,2,3))
#+end_src

We are left with a matrix of the components of our favorite (symmetric) tensor.
We can also contract the Stokeslet with a (force) vector to give the Stokeslet velocity field at a given point.
#+begin_src jupyter-julia
@btime SArray(stokeslet(x)(:,f)) setup=begin
    x = SVector{3,Float64}(1,2,3) # Position vector
    f = SVector{3,Float64}(3,2,1) # Force vector
end
#+end_src

If we use a ~StdUnitVector~ as one of the vectors, we should get the corresponding column/row of the Stokeslet as a matrix.
#+begin_src jupyter-julia
@btime SArray(stokeslet(x)(:,f)) setup=begin
    x = SVector{3,Float64}(1,2,3)
    f = ê{3}(2)
end
#+end_src

Computational cost is reduced if you contract the Stokeslet with a vector because the "full" matrix is never formed.
Contraction with a unit vector is even cheaper, since it is equivalent to forming just one row of the Stokeslet.
We can even compute just a single component of the velocity as a scalar.
#+begin_src jupyter-julia
@btime stokeslet(x)(e,f) setup=begin
    x = SVector{3,Float64}(1,2,3)
    # Direction of flow diagonally on xy plane
    e = normalize(SVector{3,Float64}(1,1,0))
    f = SVector{3,Float64}(3,2,1)
end
#+end_src

As it is possible to pick out a row/column, it is also possible to pick out just one component of the Stokeslet by feeding it two ~StdUnitVector~​s.
#+begin_src jupyter-julia
@btime stokeslet(x)(e,f) setup=begin
    x = SVector{3,Float64}(1,2,3)
    e = ê{3}(1)
    f = ê{3}(2)
end
#+end_src

Note that, in all cases, most of the computational cost of evaluating a Stokeslet is actually due to computation of the spatial dependence (taking ~norm(x)~, etc.), though this can be somewhat reduced by annotating the definition of ~stokeslet~ with ~@fastmath~.
#+begin_src jupyter-julia
@btime stokeslet(x) setup=(x = SVector{3}(1., 2., 3.));
#+end_src

Without all this machinery, the Stokeslet is not too hard to express using facilities from ~Base~ and ~LinearAlgebra~.
#+begin_src jupyter-julia
function stokeslet2(x)
    recip_r = inv(norm(x))
    x̂ = x * recip_r
    prefactor = recip_r / 8π
    (SMatrix{3,3,Float64}(I) .+ x̂ .* x̂') .* prefactor
end
@btime stokeslet2(SVector(1.,2,3))
#+end_src

Our code is actually a hair faster it seems!

However, the real advantage is mental workload.
To get the matrix-vector product to get the fluid velocity, you can either do the inefficient method of calling the function above and then calling ~dot~, or writing a whole separate function to do things the algorithmically most efficient way.
#+begin_src jupyter-julia
function stokeslet_dot_f(x, f)
    recip_r = inv(norm(x))
    x̂ = x * recip_r
    prefactor = recip_r / 8π
    (f .+ x̂.*(x̂⋅f)) .* prefactor
end
let f = normalize(rand(SVector{3}))
    x = rand(SVector{3})
    @btime stokeslet2($x) * $f  # Less efficient
    @btime stokeslet_dot_f($x, $f)
end
#+end_src

If we include third order tensors (e.g. stresslets), the ergonomic advantages of ~MultilinearForms~ are significantly more apparent.

#+begin_src jupyter-julia :results silent
function stresslet(x)
    recip_r = inv(norm(x))
    _8π = convert(eltype(x), 8) * π
    radial_fn = recip_r^2 / _8π
    n̂ = x * recip_r
    angular_fn = MultilinearForm{3,3}((e1, e2, e3) ->
        3*(n̂⋅e1)*(n̂⋅e2)*(n̂⋅e3) + (e1⋅e2)*(n̂⋅e3) - (e3⋅e1)*(n̂⋅e2) - (e2⋅e3)*(n̂⋅e1))
    return MultilinearForm{3,3}((e1, e2, e3) -> radial_fn * angular_fn(e1, e2, e3))
end
#+end_src

#+begin_src jupyter-julia
@btime SArray(stresslet(x)(:,n,f)) setup=begin
    f = normalize(SVector(1,1,0))
    x = SVector(1.,2,3)
    n = ê{3}(1)
end
#+end_src

** Evaluation at multiple points

Stokeslets at many points:
#+begin_src jupyter-julia
let n = 10000
    xs = rand(SVector{3,Float64}, n)
    xs_grid = (SVector{3,Float64}(x,y,0) for x in LinRange(-1, 1, 100), y in LinRange(-1, 1, 100))
    fs = rand(SVector{3,Float64}, n)

    ElT_mat = similar_type(stokeslet(first(xs)))
    ElT_vec = similar_type(stokeslet(first(xs))(:, first(fs)))
    buf_mat = Vector{ElT_mat}(undef, n)
    buf_vec = Vector{ElT_vec}(undef, n)
    # buf = @btime Vector{$ElT}(undef, $n)  # alloc time is ~500-600ns

    # Inlining is important here!
    @inline fun(x) = SArray(stokeslet(x))
    @inline fun(x,f) = SArray(stokeslet(x)(:,f))

    @btime SArray(stokeslet(first($xs)))                 # one evaluation
    @btime map!($fun, $buf_mat, $xs)                     # many evalutations
    @btime SArray(stokeslet(first($xs))(:, first($fs)))  # one evaluation
    @btime map!($fun, $buf_vec, $xs, $fs)                # many evalutations
end
#+end_src


Plot the Stokeslet, for fun.
#+begin_src jupyter-julia
using CairoMakie

let x⃗s = (SVector(x, y, 0.) for x ∈ LinRange(-3, 3, 201), y ∈ LinRange(-3, 3, 201))
    f⃗ = StdUnitVector{3}(1)  # = 𝐞̂ₓ
    n⃗ = StdUnitVector{3}(2)  # = 𝐞̂ₓ
    x⃗ = first(x⃗s)
    # @btime SArray(stokeslet($(Ref(x⃗))[])(:, $(Ref(f⃗))[]))
    # @btime map(x⃗ -> SArray(stokeslet(x⃗)(:, $f⃗)), $x⃗s)

    # Makie needs a function in a rather speficic format.
    on_xy_plane(form, args) = x -> Point2f(SArray(form(SVector(x..., 0.))(args))[SOneTo(2)])
    streamplot(on_xy_plane(stresslet, (:,n⃗,f⃗)), -3..3, -2..2, axis=(;aspect=DataAspect()))
end
#+end_src

** Known issues

*** Collection to a ~StaticArrays.Scalar~ is broken.

#+begin_src jupyter-julia
@btime SArray(stokeslet(x)(e,f)) setup=begin
    x = SVector{3,Float64}(1,2,3)
    e = SVector{3,Float64}(1,1,1)
    f = SVector{3,Float64}(3,2,1)
end
#+end_src


* Directions for future development

** Generalization to multilinear maps
- May need to attach vector spaces to vectors in some new type.  The multilinear map would contain as a property the vector space for each vector argument.  The vector space itself would consist of a basis and dual basis.
- During collection to an array, shape would have to be explicitly specified
- Specific shapes can be specified in a subtype
